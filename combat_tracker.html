<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Combat Tracker</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Custom styles for Combat Tracker */
    #tracker-controls {
      margin-bottom: 10px;
    }
    #tracker-controls button {
      margin-right: 10px;
    }
    /* Set initial work area size; it will expand as needed */
    #combat-tracker {
      position: relative;
      width: 1000px;
      height: 700px;
      background: #1a1a1a;
      border: 1px solid #444;
      overflow: auto;
    }
    /* ZONE (bigger by default) */
    .zone {
      position: absolute;
      width: 200px;
      height: 120px;
      background: rgba(0, 128, 128, 0.2);
      border: 2px solid teal;
      color: #ccc;
      text-align: center;
      line-height: 120px;
      cursor: move;
      user-select: none;
      box-sizing: border-box;
    }
    /* TOKEN (rectangular) with internal label */
    .token {
      position: absolute;
      width: 60px;
      height: 40px;
      background: #888;
      border: 2px solid #ccc;
      box-sizing: border-box;
      cursor: move;
      user-select: none;
    }
    /* The token label – separate so renaming doesn’t disturb other controls */
    .token .token-label {
      display: block;
      text-align: center;
      line-height: 40px;
      pointer-events: none;
      color: #000;
    }
    /* Delete button for tokens */
    .delete-btn {
      position: absolute;
      top: 0;
      right: 0;
      background: #f00;
      color: #fff;
      font-size: 10px;
      border: none;
      cursor: pointer;
      padding: 2px 4px;
      z-index: 20;
    }
    /* We now only use the cover-none style */
    .cover-none {
      border-color: #ccc;
    }
    /* SVG overlay for drawing connections */
    #connection-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    /* Resizer handle (bottom-right corner) */
    .resizer {
      position: absolute;
      width: 14px;
      height: 14px;
      bottom: 0;
      right: 0;
      background: #444;
      border: 1px solid #888;
      cursor: se-resize;
      z-index: 10;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">System Generator</a> |
    <a href="lifepath.html">Lifepath Generator</a> |
    <a href="weapongenerator.html">Weapon Generator</a> |
    <a href="combat_tracker.html">Combat Tracker</a>
  </nav>
  
  <div class="container">
    <h2>Astral Axial Combat Tracker</h2>
    <div id="tracker-controls">
      <button id="add-zone-btn">Add Zone</button>
      <button id="add-token-btn">Add Token</button>
      <button id="link-zones-btn">Link Zones</button>
      <button id="clear-links-btn">Clear Links</button>
      <span id="link-mode-indicator" style="color: yellow; margin-left: 10px;"></span>
    </div>
    <div id="combat-tracker">
      <!-- SVG overlay for connection arrows -->
      <svg id="connection-overlay">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="teal" />
          </marker>
        </defs>
      </svg>
    </div>
  </div>

  <script>
    // Global variables for link mode and connection tracking
    let isLinkMode = false;
    let linkStartZone = null;
    let connections = [];

    const tracker = document.getElementById('combat-tracker');
    const svgOverlay = document.getElementById('connection-overlay');

    // Utility: generate unique IDs for new elements
    function uniqueId(prefix='id') {
      return prefix + '-' + Math.random().toString(36).substr(2, 9);
    }

    // Check and expand work area if an element is dragged near the right or bottom edge
    function checkExpandWorkArea(el) {
      let padding = 50; // threshold before expanding
      let currentWidth = tracker.offsetWidth;
      let currentHeight = tracker.offsetHeight;
      let elLeft = parseInt(el.style.left) || 0;
      let elTop = parseInt(el.style.top) || 0;
      let elRight = elLeft + el.offsetWidth;
      let elBottom = elTop + el.offsetHeight;
      let newWidth = currentWidth;
      let newHeight = currentHeight;
      if (elRight > currentWidth - padding) {
        newWidth = elRight + padding;
      }
      if (elBottom > currentHeight - padding) {
        newHeight = elBottom + padding;
      }
      if (newWidth > currentWidth) {
        tracker.style.width = newWidth + "px";
      }
      if (newHeight > currentHeight) {
        tracker.style.height = newHeight + "px";
      }
    }

    // Enable dragging for zones/tokens
    function makeDraggable(el) {
      let offsetX, offsetY;
      el.addEventListener('mousedown', dragMouseDown);

      function dragMouseDown(e) {
        // Ignore if clicking on the resizer or delete button
        if (e.target.classList.contains('resizer') || e.target.classList.contains('delete-btn')) return;

        // In link mode, if clicking on a zone, use it for connection
        if (isLinkMode && el.classList.contains('zone')) {
          handleLinking(el);
          e.stopPropagation();
          return;
        }
        e.preventDefault();
        offsetX = e.clientX - el.getBoundingClientRect().left;
        offsetY = e.clientY - el.getBoundingClientRect().top;
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('mouseup', closeDragElement);
      }

      function elementDrag(e) {
        e.preventDefault();
        let trackerRect = tracker.getBoundingClientRect();
        let newX = e.clientX - trackerRect.left - offsetX;
        let newY = e.clientY - trackerRect.top - offsetY;
        // Ensure the element doesn't go negative
        newX = Math.max(0, newX);
        newY = Math.max(0, newY);
        el.style.left = newX + 'px';
        el.style.top = newY + 'px';
        updateConnections(el);
        checkExpandWorkArea(el);
      }

      function closeDragElement() {
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('mouseup', closeDragElement);
      }
    }

    // Enable resizing for zones/tokens
    function makeResizable(el) {
      const resizer = document.createElement('div');
      resizer.classList.add('resizer');
      el.appendChild(resizer);

      resizer.addEventListener('mousedown', initResize);

      function initResize(e) {
        e.stopPropagation(); // Prevent triggering drag
        e.preventDefault();
        document.addEventListener('mousemove', startResizing);
        document.addEventListener('mouseup', stopResizing);
      }

      function startResizing(e) {
        let trackerRect = tracker.getBoundingClientRect();
        let rect = el.getBoundingClientRect();
        // Calculate new width/height based on mouse
        let newWidth = e.clientX - rect.left;
        let newHeight = e.clientY - rect.top;
        // Set minimum sizes
        newWidth = Math.max(40, newWidth);
        newHeight = Math.max(30, newHeight);
        // Ensure the element doesn't extend outside the tracker initially
        let maxWidth = tracker.offsetWidth - (rect.left - trackerRect.left);
        let maxHeight = tracker.offsetHeight - (rect.top - trackerRect.top);
        newWidth = Math.min(newWidth, maxWidth);
        newHeight = Math.min(newHeight, maxHeight);
        el.style.width = newWidth + 'px';
        el.style.height = newHeight + 'px';
        // For zones, adjust line-height to vertically center text
        if (el.classList.contains('zone')) {
          el.style.lineHeight = newHeight + 'px';
        }
        updateConnections(el);
        checkExpandWorkArea(el);
      }

      function stopResizing() {
        document.removeEventListener('mousemove', startResizing);
        document.removeEventListener('mouseup', stopResizing);
      }
    }

    // Create and add a delete button for tokens
    function addDeleteButton(token) {
      const delBtn = document.createElement('button');
      delBtn.classList.add('delete-btn');
      delBtn.textContent = 'X';
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        // Remove token and update connections if needed
        token.parentElement.removeChild(token);
        connections = connections.filter(conn => conn.zoneA !== token && conn.zoneB !== token);
      });
      token.appendChild(delBtn);
    }

    // Handler for "Add Zone" button
    document.getElementById('add-zone-btn').addEventListener('click', () => {
      const zone = document.createElement('div');
      zone.classList.add('zone');
      zone.id = uniqueId('zone');
      zone.textContent = 'Zone';

      // Random starting position within tracker
      zone.style.left = Math.random() * (tracker.offsetWidth - 200) + 'px';
      zone.style.top = Math.random() * (tracker.offsetHeight - 120) + 'px';

      tracker.appendChild(zone);
      makeDraggable(zone);
      makeResizable(zone);

      // Allow renaming the zone on double-click
      zone.addEventListener('dblclick', () => {
        const newLabel = prompt('Enter zone label:', zone.textContent);
        if (newLabel !== null) {
          zone.textContent = newLabel;
          // Re-add the resizer since renaming wipes out child nodes
          makeResizable(zone);
        }
      });
    });

    // Handler for "Add Token" button
    document.getElementById('add-token-btn').addEventListener('click', () => {
      const token = document.createElement('div');
      token.classList.add('token', 'cover-none');
      token.id = uniqueId('token');

      // Create a separate span for the token label
      const labelSpan = document.createElement('span');
      labelSpan.classList.add('token-label');
      labelSpan.textContent = 'T';
      token.appendChild(labelSpan);

      // Set random starting position within tracker
      token.style.left = Math.random() * (tracker.offsetWidth - 60) + 'px';
      token.style.top = Math.random() * (tracker.offsetHeight - 40) + 'px';

      tracker.appendChild(token);
      makeDraggable(token);
      makeResizable(token);
      addDeleteButton(token);

      // Rename token on double-click without interfering with the resizer or delete button
      token.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        const newLabel = prompt('Enter token label:', labelSpan.textContent);
        if (newLabel !== null) {
          labelSpan.textContent = newLabel;
        }
      });
    });

    // Toggle link mode for connecting zones
    document.getElementById('link-zones-btn').addEventListener('click', () => {
      isLinkMode = !isLinkMode;
      linkStartZone = null;
      document.getElementById('link-mode-indicator').textContent = isLinkMode ? 'Link Mode: ON' : '';
    });

    // Clear all drawn connections
    document.getElementById('clear-links-btn').addEventListener('click', () => {
      connections.forEach(conn => {
        svgOverlay.removeChild(conn.line);
      });
      connections = [];
    });

    // Handle zone selection when in link mode
    function handleLinking(zone) {
      if (!linkStartZone) {
        linkStartZone = zone;
        zone.style.borderColor = 'yellow';
      } else if (linkStartZone === zone) {
        // Deselect if same zone is clicked
        zone.style.borderColor = 'teal';
        linkStartZone = null;
      } else {
        // Create connection between the two zones
        createConnection(linkStartZone, zone);
        linkStartZone.style.borderColor = 'teal';
        zone.style.borderColor = 'teal';
        linkStartZone = null;
      }
    }

    // Create an SVG line (with an arrowhead) between two zones
    function createConnection(zoneA, zoneB) {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('stroke', 'teal');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      svgOverlay.appendChild(line);
      const conn = { zoneA, zoneB, line };
      connections.push(conn);
      updateLinePosition(conn);
    }

    // Recalculate line endpoints from border to border
    function updateLinePosition(conn) {
      const { zoneA, zoneB, line } = conn;
      let rectA = zoneA.getBoundingClientRect();
      let rectB = zoneB.getBoundingClientRect();
      let trackerRect = tracker.getBoundingClientRect();

      // Calculate center points in tracker coordinates
      let centerA = {
        x: rectA.left + rectA.width / 2 - trackerRect.left,
        y: rectA.top + rectA.height / 2 - trackerRect.top
      };
      let centerB = {
        x: rectB.left + rectB.width / 2 - trackerRect.left,
        y: rectB.top + rectB.height / 2 - trackerRect.top
      };

      let start = getBorderPoint(zoneA, centerB.x, centerB.y);
      let end = getBorderPoint(zoneB, centerA.x, centerA.y);

      line.setAttribute('x1', start.x);
      line.setAttribute('y1', start.y);
      line.setAttribute('x2', end.x);
      line.setAttribute('y2', end.y);
    }

    // Calculate where a line from the center of an element toward (targetX, targetY) hits its border
    function getBorderPoint(el, targetX, targetY) {
      const rect = el.getBoundingClientRect();
      const trackerRect = tracker.getBoundingClientRect();
      let zx = rect.left + rect.width / 2 - trackerRect.left;
      let zy = rect.top + rect.height / 2 - trackerRect.top;
      let dx = targetX - zx;
      let dy = targetY - zy;
      if (dx === 0 && dy === 0) return { x: zx, y: zy };
      let tValues = [];
      let left = rect.left - trackerRect.left;
      let right = left + rect.width;
      let top = rect.top - trackerRect.top;
      let bottom = top + rect.height;
      if (dx !== 0) {
        let tLeft = (left - zx) / dx;
        if (tLeft >= 0 && tLeft <= 1) tValues.push(tLeft);
        let tRight = (right - zx) / dx;
        if (tRight >= 0 && tRight <= 1) tValues.push(tRight);
      }
      if (dy !== 0) {
        let tTop = (top - zy) / dy;
        if (tTop >= 0 && tTop <= 1) tValues.push(tTop);
        let tBottom = (bottom - zy) / dy;
        if (tBottom >= 0 && tBottom <= 1) tValues.push(tBottom);
      }
      if (tValues.length === 0) return { x: zx, y: zy };
      let tMin = Math.min(...tValues);
      return { x: zx + dx * tMin, y: zy + dy * tMin };
    }

    // When an element moves or resizes, update any connection lines it’s involved in
    function updateConnections(movedElement) {
      connections.forEach(conn => {
        if (conn.zoneA === movedElement || conn.zoneB === movedElement) {
          updateLinePosition(conn);
        }
      });
    }
  </script>
</body>
</html>
