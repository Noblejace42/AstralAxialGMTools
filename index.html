<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Astral Axial System Generator</title>
  <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
  <nav>
    <a href="index.html">System Generator</a> |
    <a href="lifepath.html">Lifepath Generator</a> |
    <a href="weapongenerator.html">Weapon Generator</a> |
    <a href="combat_tracker.html">Combat Tracker</a>
  </nav>

  <div class="container">
    <h1>Astral Axial System Generator</h1>
    <!-- Main output container where the system and settlements will be rendered -->
    <div id="systemOutput"></div>
    <!-- Button to generate a new system -->
    <button id="generateSystemButton" class="btn-system">
      Generate System
    </button>
    <!-- Advanced options panel (collapsible/hidden for now) -->
    <div id="advancedOptions" style="display: none;">
      <h2>Advanced Settings</h2>
      <!-- Future dynamic UI elements can be injected here -->
    </div>
  </div>

  <div class="art-credit">
    <a href="https://www.instagram.com/vinny.longbow?igsh=c203czNuMW92MXA3" target="_blank">
      Art Credit: Vincent Fleetwood
    </a>
  </div>

  <script>
    // Global variables to hold the configuration and generated system data.
    let config = null;
    let systemData = null;

    // Utility Functions
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function weightedRandom(choices) {
      const totalWeight = choices.reduce((sum, choice) => sum + choice.weight, 0);
      let randomNum = Math.random() * totalWeight;
      for (const choice of choices) {
        if (randomNum < choice.weight) {
          return choice.value !== undefined ? choice.value : choice.name;
        }
        randomNum -= choice.weight;
      }
    }

    // Fetch the external configuration JSON file.
    async function loadConfig() {
      try {
        const response = await fetch('systemgeneratorinfo.json');
        config = await response.json();
        console.log('Config loaded:', config);
      } catch (error) {
        console.error('Failed to load config:', error);
      }
    }

    // --- System Generation Functions ---

    // Generate a system code using the format defined in the config.
    function generateSystemCode() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const digits = "0123456789";
      let code = "";
      // Following a "LLDDLD" pattern (two letters, two digits, one letter, one digit)
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      return code;
    }

    // Generate the overall system including planets and settlements.
    function generateSystem() {
      const code = generateSystemCode();
      const prefix = weightedRandom(config.names.settlementPrefix);
      const core = weightedRandom(config.names.settlementCore);
      const systemDesignation = prefix + core;
      const systemName = code + " " + systemDesignation;

      // Generate planets.
      const planetCountRange = config.system.planetCountRange;
      const numPlanets = randomInt(planetCountRange.min, planetCountRange.max);
      let planets = [];

      if (numPlanets > 0) {
        // Use planet biomes from the config's conditions; here we use the "planet" array.
        const planetBiomes = config.conditions.planet;
        for (let i = 1; i <= numPlanets; i++) {
          const biome = planetBiomes[randomInt(0, planetBiomes.length - 1)];
          const planetName = systemDesignation + " " + toRoman(i);
          planets.push({
            name: planetName,
            biome: biome,
            settlements: []
          });
        }
      }

      // Generate settlements.
      let settlements = [];
      let settlementCountOptions = config.system.settlementCountOptions;
      let numSettlements = weightedRandom(settlementCountOptions);
      let forcedType = false;
      if (numPlanets === 0) {
        numSettlements = 1;
        forcedType = true;
      }
      for (let i = 0; i < numSettlements; i++) {
        settlements.push(generateSettlementData(forcedType));
      }

      // Distribute settlements among planets (if any exist).
      if (numPlanets > 0) {
        planets.forEach(planet => planet.settlements = []);
        settlements.forEach(settlement => {
          const idx = randomInt(0, numPlanets - 1);
          planets[idx].settlements.push(settlement);
        });
      }

      // Generate system conditions using the reference provided in the config.
      let sysConditions = [];
      if (config.system.systemConditions && typeof config.system.systemConditions === 'string') {
        // Resolve reference, e.g., "conditions.system" maps to config.conditions.system.
        const ref = config.system.systemConditions.split('.');
        let current = config;
        ref.forEach(part => {
          current = current[part];
        });
        if (Array.isArray(current)) {
          sysConditions = current.sort(() => Math.random() - 0.5).slice(0, randomInt(0, 3));
        }
      }

      systemData = {
        systemName: systemName,
        planets: planets,
        settlements: numPlanets === 0 ? settlements : null,
        sysConditions: sysConditions
      };

      renderSystem();
    }

    // Helper function: convert a number to a Roman numeral.
    function toRoman(num) {
      const romans = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"];
      return romans[num - 1] || num;
    }

    // --- Settlement Generation Functions ---

    function generateSettlementData(forceType = false) {
      // Decide the settlement type.
      let settlementType;
      if (forceType) {
        settlementType = config.settlement.settlementTypes.station;
      } else {
        const types = Object.values(config.settlement.settlementTypes);
        settlementType = types[randomInt(0, types.length - 1)];
        if (settlementType.forceType) {
          forceType = true;
        }
      }

      // Name generation.
      const prefix = weightedRandom(config.names.settlementPrefix);
      const core = weightedRandom(config.names.settlementCore);
      let suffix;
      if (forceType && settlementType.forceType) {
        suffix = settlementType.name;
      } else {
        suffix = weightedRandom(config.names.settlementSuffix);
      }
      const name = prefix + core + " " + suffix;

      // Development level.
      const development = weightedRandom(config.settlement.developmentLevels);

      // Population calculation using a multiplier from the settlement type.
      let maxPop = 1000 * development;
      if (forceType && settlementType.forceType) {
        maxPop = 100;
      } else {
        maxPop = Math.min(maxPop, 10000);
      }
      const population = randomInt(20, maxPop);

      // Government and important figure.
      const government = weightedRandom(config.settlement.governments);
      const jobTitle = weightedRandom(config.settlement.jobTitles);
      const firstName = weightedRandom(config.names.firstNamePrefixes) + weightedRandom(config.names.firstNameSuffixes);
      const lastName = weightedRandom(config.names.lastNamePrefixes) + weightedRandom(config.names.lastNameSuffixes);
      const importantFigure = jobTitle + " " + firstName + " " + lastName;

      // Generate core scores and apply type-specific modifiers.
      const scores = {};
      for (let key in config.settlement.scores) {
        const base = config.settlement.scores[key].base;
        scores[key] = randomInt(base.min, base.max);
        if (settlementType.scoreModifiers && settlementType.scoreModifiers[key]) {
          scores[key] += settlementType.scoreModifiers[key];
        }
      }

      // Generate exports based on development.
      let exportsGenerated = [];
      if (development <= 5) {
        const pool = config.settlement.exports.lowDevelopment.slice();
        pool.sort(() => Math.random() - 0.5);
        const count = randomInt(1, 5);
        exportsGenerated = pool.slice(0, count);
      } else {
        const pool = config.settlement.exports.highDevelopment.slice();
        pool.sort(() => Math.random() - 0.5);
        const count = randomInt(1, 5);
        exportsGenerated = pool.slice(0, count);
      }

      // Settlement conditions.
      let conds = config.settlement.conditions.settlement.slice();
      conds.sort(() => Math.random() - 0.5);
      conds = conds.slice(0, randomInt(0, 3));

      // Points of interest.
      let poi = [];
      if (Math.random() > 0.5) {
        poi = exportsGenerated.slice();
      }

      // Generate military data.
      const military = generateMilitaryData(population, forceType);

      // Trader generation module (if enabled in the config).
      let traders = [];
      if (config.settlement.traders.enabled) {
        const traderCount = randomInt(config.settlement.traders.defaultCountRange.min, config.settlement.traders.defaultCountRange.max);
        for (let i = 0; i < traderCount; i++) {
          const traderType = weightedRandom(config.settlement.traders.traderTypes);
          const wealth = randomInt(traderType.baseWealth.min, traderType.baseWealth.max);
          const charisma = randomInt(traderType.charisma.min, traderType.charisma.max);
          traders.push({
            type: traderType.type,
            wealth,
            charisma,
            specialTraits: traderType.specialTraits
          });
        }
      }

      return {
        name,
        development,
        population,
        government,
        importantFigure,
        scores,
        exports: exportsGenerated,
        conditions: conds,
        pointsOfInterest: poi,
        military,
        traders
      };
    }

    function generateMilitaryData(population, forcedStation) {
      const minSoldiers = Math.floor(population * config.settlement.military.soldiers.populationPercentage.min);
      const maxSoldiers = Math.floor(population * config.settlement.military.soldiers.populationPercentage.max);
      const soldiers = randomInt(minSoldiers, maxSoldiers);

      const minVehicles = Math.max(1, Math.floor(soldiers / config.settlement.military.armoredVehicles.soldierPerVehicle.max));
      const maxVehicles = Math.max(1, Math.floor(soldiers / config.settlement.military.armoredVehicles.soldierPerVehicle.min));
      const armoredVehicles = randomInt(minVehicles, maxVehicles);

      let ships = {};
      if (config.settlement.military.ships.enabled) {
        let totalShips = 0;
        if (forcedStation) {
          totalShips = randomInt(config.settlement.military.ships.forcedStationMinimum.min, config.settlement.military.ships.forcedStationMinimum.max);
        } else if (population >= config.settlement.military.ships.defaultMinimumPopulation) {
          totalShips = randomInt(config.settlement.military.ships.defaultShipCountRange.min, config.settlement.military.ships.defaultShipCountRange.max);
        }
        config.settlement.military.ships.baseShipTypes.forEach(shipType => {
          ships[shipType.name] = 0;
        });
        for (let i = 0; i < totalShips; i++) {
          const chosenType = weightedRandom(config.settlement.military.ships.baseShipTypes);
          ships[chosenType.name] += 1;
        }
      }
      return { soldiers, armoredVehicles, ships };
    }

    // --- Rendering Functions ---

    function renderSettlement(settlement, planetIndex, settlementIndex) {
      let shipStr = "";
      if (settlement.military.ships) {
        for (let type in settlement.military.ships) {
          if (settlement.military.ships[type] > 0) {
            shipStr += `${type} x${settlement.military.ships[type]} `;
          }
        }
      }
      if (shipStr === "") shipStr = "None";

      // Render trader list if available.
      let tradersHtml = "";
      if (settlement.traders && settlement.traders.length > 0) {
        tradersHtml = `<ul>`;
        settlement.traders.forEach(trader => {
          tradersHtml += `<li>${trader.type} (Wealth: ${trader.wealth}, Charisma: ${trader.charisma})</li>`;
        });
        tradersHtml += `</ul>`;
      }

      return `
      <div class="settlement" id="settlement-${planetIndex}-${settlementIndex}">
        <div class="settlement-output">
          <strong>Name:</strong> ${settlement.name} <br>
          <strong>Development:</strong> ${settlement.development} <br>
          <strong>Population:</strong> ${settlement.population} <br>
          <strong>Government:</strong> ${settlement.government} <br>
          <strong>Important Figure:</strong> ${settlement.importantFigure} <br>
          <strong>Scores:</strong> Militarism: ${settlement.scores.militarism}, Prosperity: ${settlement.scores.prosperity}, Trade: ${settlement.scores.trade}, Stability: ${settlement.scores.stability} <br>
          <strong>Exports:</strong> ${settlement.exports.join(", ") || "None"} <br>
          <strong>Conditions:</strong> ${settlement.conditions.join(", ") || "None"} <br>
          <strong>Points of Interest:</strong> ${settlement.pointsOfInterest.join(", ") || "None"} <br>
          <strong>Military:</strong> Soldiers: ${settlement.military.soldiers}, Armored Vehicles: ${settlement.military.armoredVehicles}, Ships: ${shipStr} <br>
          <strong>Traders:</strong> ${tradersHtml || "None"}
        </div>
        <button onclick="regenerateSettlement(${planetIndex}, ${settlementIndex})" class="${config.ui.elements.regenerateButton.class}">
          ${config.ui.elements.regenerateButton.label}
        </button>
      </div>`;
    }

    function renderSystem() {
      const outputDiv = document.getElementById("systemOutput");
      let html = `<div class="section">
        <h2>System: ${systemData.systemName}</h2>
        <p><strong>System Conditions:</strong> ${systemData.sysConditions.join(", ") || "None"}</p>
        <p><strong>Number of Planets:</strong> ${systemData.planets.length}</p>
        <p><strong>Number of Settlements:</strong> ${
          systemData.planets.length > 0
            ? systemData.planets.reduce((sum, p) => sum + p.settlements.length, 0)
            : systemData.settlements.length
        }</p>
      </div>`;

      if (systemData.planets.length > 0) {
        systemData.planets.forEach((planet, pIndex) => {
          html += `<div class="section planet">
            <h3>Planet: ${planet.name}</h3>
            <p><strong>Biome:</strong> ${planet.biome}</p>`;
          if (planet.settlements.length > 0) {
            planet.settlements.forEach((settlement, sIndex) => {
              html += renderSettlement(settlement, pIndex, sIndex);
            });
          } else {
            html += `<p>No settlements on this planet.</p>`;
          }
          html += `</div>`;
        });
      } else {
        html += `<div class="section">
          <h3>Settlement (Space Station):</h3>
          ${renderSettlement(systemData.settlements[0], 0, 0)}
        </div>`;
      }
      outputDiv.innerHTML = html;
    }

    function regenerateSettlement(planetIndex, settlementIndex) {
      if (systemData.planets.length > 0) {
        systemData.planets[planetIndex].settlements[settlementIndex] = generateSettlementData();
        renderSystem();
      } else {
        systemData.settlements[settlementIndex] = generateSettlementData(true);
        renderSystem();
      }
    }

    // --- Event Listeners ---

    document.getElementById("generateSystemButton").addEventListener("click", generateSystem);

    // Initial load: fetch configuration then wait for user interaction.
    loadConfig().then(() => {
      // Optionally auto-generate a system on load:
      // generateSystem();
    });
  </script>
</body>
</html>
