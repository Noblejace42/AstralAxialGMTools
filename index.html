<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Emerson Neher</title>

  <!-- Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible&display=swap">
  <!-- Main Styles -->
  <link rel="stylesheet" href="home.css" />
</head>
<body>

  <!-- Center Card -->
  <div class="center-card" id="centerCard">
    <!-- Buttons Row -->
    <div class="card-buttons">
      <a href="systemgen.html" class="card-btn">Astral Axial</a>
      <a href="https://emersonneher.substack.com" target="_blank" class="card-btn">Hopeless Poetic</a>
      <a href="#" class="card-btn">Miscellaneous</a>
    </div>

    <!-- Personal Image -->
    <div class="card-image">
      <img src="image/sittingimage.jpg" alt="Emerson Neher" />
    </div>

    <!-- Contact Info -->
    <div class="contact-card">
      <h1>Emerson Neher</h1>
      <h3>they/them/theirs</h3>
      <p>Email: <a href="mailto:emersonneher@gmail.com">emersonneher@gmail.com</a></p>
      <p>Worcester, MA &amp; Evergreen, CO</p>
      <p>
        Worcester Polytechnic Institute | Class of 2028<br />
        Financial Technology Major | Information Systems Major
      </p>
      <p class="links">
        <a href="https://www.linkedin.com/in/emerson-neher-184274346" target="_blank">LinkedIn</a> |
        <a href="https://www.instagram.com/emerson.neher/" target="_blank">Instagram</a> |
        <a href="https://discord.com/users/noblejace" target="_blank">Discord</a>
      </p>
      <p class="bio">
        Passionate about technology, finance, and systems design. Iâ€™m a writer, game designer, and storyteller 
        who finds inspiration in the rhythm of poetry, the mechanics of RPGs, and the art of photography. 
        Whether crafting immersive worlds, capturing fleeting moments, or experimenting with new game systems, 
        I love exploring the intersection of creativity and experience.
      </p>
    </div>

    <!-- Smaller Spotify Embed (blue style) -->
    <div class="spotify-container">
      <h3 class="spotify-title">Currently Listening</h3>
      <iframe 
        style="border-radius:12px; width:100%;"
        src="https://open.spotify.com/embed/playlist/0FdmEAvUL4hFCzBDev8n6J?utm_source=generator&theme=1" 
        width="100%" 
        height="180" 
        frameborder="0" 
        allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
        loading="lazy">
      </iframe>
    </div>

  </div>

  <!-- Container for moving images -->
  <div class="tiles-container"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {

      /***************************************************************
       * 1) Center the card 
       ***************************************************************/
      const centerCard = document.getElementById('centerCard');
      function centerTheCard() {
        const rect = centerCard.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        // Ensure some breathing room from the top
        const topPos = Math.max(10, (vh - rect.height) / 2);
        centerCard.style.left = (vw - rect.width) / 2 + 'px';
        centerCard.style.top  = topPos + 'px';
      }
      window.addEventListener('resize', centerTheCard);
      centerTheCard();

      /***************************************************************
       * 2) Preload images and store their aspect ratios 
       ***************************************************************/
      const tilePaths = [];
      for (let i = 4; i <= 37; i++) {
        tilePaths.push(`image/${i}.jpg`);
      }
      // Additional image paths can be added here if needed

      let loadedCount = 0;
      const tileData = [];

      tilePaths.forEach(src => {
        const img = new Image();
        img.src = src;
        img.onload = () => {
          tileData.push({
            src,
            aspect: (img.width / img.height) || 1
          });
          loadedCount++;
          if (loadedCount === tilePaths.length) startSpawning();
        };
        img.onerror = () => {
          console.error("Error loading image:", src);
          loadedCount++;
          if (loadedCount === tilePaths.length) startSpawning();
        };
      });

      const tilesContainer = document.querySelector('.tiles-container');
      // Array to hold the bounding rectangles of spawned tiles (to prevent overlap)
      const placedRects = [];

      function getCardRect() {
        const c = centerCard.getBoundingClientRect();
        return { left: c.left, top: c.top, right: c.right, bottom: c.bottom };
      }

      function overlap(r1, r2) {
        return !(
          r1.right < r2.left ||
          r1.left > r2.right  ||
          r1.bottom < r2.top  ||
          r1.top > r2.bottom
        );
      }

      /***************************************************************
       * 3) Spawn images with random vertical positions & sizes
       *    starting from the left edge (left: 0) and animate them rightward
       ***************************************************************/
      // Spawn several images immediately then continue at a faster interval
      function startSpawning() {
        for (let i = 0; i < 8; i++) {
          spawnImage();
        }
        // Spawn a new image every 1000ms
        setInterval(spawnImage, 1000);
      }

      function spawnImage() {
        if (!tileData.length) return;
        // Pick a random image from the loaded data
        const td = tileData[Math.floor(Math.random() * tileData.length)];

        const div = document.createElement('div');
        div.classList.add('moving-tile');
        div.dataset.aspect = td.aspect;
        div.style.backgroundImage = `url('${td.src}')`;

        // Choose a random width between 150 and 350 pixels (ensuring not too small)
        const minW = 150, maxW = 350;
        const w = minW + Math.random() * (maxW - minW);
        const h = w / td.aspect;

        const vh = window.innerHeight;
        // Starting from the left edge (0px)
        const initialLeft = 0;

        // Try to find a non-overlapping vertical position
        for (let tries = 0; tries < 50; tries++) {
          const top = Math.random() * (vh - h);
          // Construct a potential rectangle for the new image
          const newRect = { left: initialLeft, top, right: initialLeft + w, bottom: top + h };

          // Ensure no overlap with the center card
          if (overlap(newRect, getCardRect())) continue;

          // Ensure no overlap with already placed tiles
          let conflict = false;
          for (const r of placedRects) {
            if (overlap(newRect, r)) {
              conflict = true;
              break;
            }
          }
          if (conflict) continue;

          // Place the image and record its rectangle
          div.style.width = w + 'px';
          div.style.height = h + 'px';
          div.style.left = initialLeft + 'px';
          div.style.top = top + 'px';
          tilesContainer.appendChild(div);
          placedRects.push(newRect);

          // Begin animation for this tile
          moveTile(div, newRect);
          return;
        }
        // If no valid position is found after 50 tries, skip spawning this tile
      }

      // Animate the tile moving rightward at a constant speed
      function moveTile(div, rect) {
        const speed = 30; // pixels per second
        const frameTime = 16; // roughly 60fps
        function animate() {
          // Update the rectangle's horizontal position
          rect.left += speed * (frameTime / 1000);
          rect.right = rect.left + parseFloat(div.style.width);
          div.style.left = rect.left + 'px';

          // Remove the tile if it has moved off the right edge
          if (rect.left > window.innerWidth + 30) {
            tilesContainer.removeChild(div);
            const idx = placedRects.indexOf(rect);
            if (idx >= 0) placedRects.splice(idx, 1);
            return;
          }
          requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

    });
  </script>

</body>
</html>
