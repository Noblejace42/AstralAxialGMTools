<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Astral Axial System Generator</title>
  <!-- Use Rajdhani for a modern, sci-fi sans-serif look -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
</head>
<body style="font-family: 'Rajdhani', sans-serif;">
  <nav>
    <a href="index.html">System Generator</a> |
    <a href="lifepath.html">Lifepath Generator</a> |
    <a href="weapongenerator.html">Weapon Generator</a> |
    <a href="combat_tracker.html">Combat Tracker</a>
  </nav>

  <div class="container">
    <h1>Astral Axial System Generator</h1>
    <div class="button-bar">
      <button id="generateSystemButton" class="btn-system">Generate System</button>
    </div>
    <div id="systemOutput"></div>
    <div id="advancedOptions" style="display: none;">
      <h2>Advanced Settings</h2>
      <!-- Future dynamic UI elements can be added here -->
    </div>
  </div>

  <div class="art-credit">
    <a href="https://www.instagram.com/vinny.longbow?igsh=c203czNuMW92MXA3" target="_blank">
      Art Credit: Vincent Fleetwood
    </a>
  </div>

  <script>
    let config = null;
    let systemData = null;

    // Helper: weighted random for objects with "baseWeight" (used for government)
    function weightedRandomBaseWeight(choices) {
      let total = 0;
      for (const c of choices) {
        total += c.baseWeight;
      }
      let rnd = Math.random() * total;
      for (const c of choices) {
        if (rnd < c.baseWeight) return c;
        rnd -= c.baseWeight;
      }
      return choices[choices.length - 1];
    }

    // Helper: weighted random for objects with "weight"
    function weightedRandom(choices) {
      let total = 0;
      for (const c of choices) {
        total += (c.weight || 1);
      }
      let rnd = Math.random() * total;
      for (const c of choices) {
        let w = (c.weight || 1);
        if (rnd < w) return c;
        rnd -= w;
      }
      return choices[choices.length - 1];
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function toRoman(num) {
      const romans = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"];
      return romans[num - 1] || num;
    }

    async function loadConfig() {
      try {
        const resp = await fetch("systemgeneratorinfo(2).json");
        config = await resp.json();
        console.log("Config loaded:", config);
      } catch (e) {
        console.error("Error loading config:", e);
      }
    }

    function generateSystemCode() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const digits = "0123456789";
      let code = "";
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      return code;
    }

    // Government selection influenced by stability and militarism
    function pickGovernment(mil, pro, sta) {
      let govArr = config.settlement.government.types.slice();
      for (let g of govArr) {
        if (g.name === "Pirate Den" && sta < 30) g.baseWeight *= 3;
        if (g.name === "Anarchic Collective" && sta < 30) g.baseWeight *= 2;
        if ((g.name === "Democracy" || g.name === "Elected Governor" || g.name === "Technocratic Council") && sta > 70) {
          g.baseWeight *= 3;
        }
        if (g.name === "Military Junta" && mil > 70) g.baseWeight *= 2;
      }
      return weightedRandomBaseWeight(govArr).name;
    }

    function pickRulerTitle(mil, pro, sta) {
      return weightedRandomBaseWeight(config.settlement.government.rulerTitles).title;
    }

    // Generate system with weighted settlement count (0-10, favoring 0/1)
    function generateSystem() {
      let code = generateSystemCode();
      let pre = weightedRandom(config.system.nameComponents.prefix);
      let co = weightedRandom(config.system.nameComponents.core);
      let sysDesignation = pre.name + co.name;
      let systemName = code + " " + sysDesignation;

      const settlementCountOptions = [
        { value: 0, weight: 5 },
        { value: 1, weight: 4 },
        { value: 2, weight: 3 },
        { value: 3, weight: 2 },
        { value: 4, weight: 1 },
        { value: 5, weight: 1 },
        { value: 6, weight: 1 },
        { value: 7, weight: 1 },
        { value: 8, weight: 1 },
        { value: 9, weight: 1 },
        { value: 10, weight: 1 }
      ];
      let totalWeight = settlementCountOptions.reduce((sum, opt) => sum + opt.weight, 0);
      let rnd = Math.random() * totalWeight;
      let finalSettlementCount = 0;
      for (let opt of settlementCountOptions) {
        if (rnd < opt.weight) {
          finalSettlementCount = opt.value;
          break;
        }
        rnd -= opt.weight;
      }

      // Planet generation: 0 to 6 planets
      const planetRange = config.system.planetCountRange || { min: 0, max: 6 };
      let planetCount = randomInt(planetRange.min, planetRange.max);
      let planets = [];
      if (planetCount > 0) {
        for (let i = 1; i <= planetCount; i++) {
          let planetType = weightedRandom(config.planet.types);
          let biome = config.planet.conditions[randomInt(0, config.planet.conditions.length - 1)];
          let planetName = sysDesignation + " " + toRoman(i);
          planets.push({
            name: planetName,
            biome: biome,
            type: planetType,
            settlements: []
          });
        }
      }

      // If no planets and settlements are forced, generate forced stations
      if (planetCount === 0 && finalSettlementCount > 0) {
        let forcedSetts = [];
        for (let i = 0; i < finalSettlementCount; i++) {
          forcedSetts.push(generateSettlementData(true));
        }
        systemData = {
          systemName,
          planets: [],
          settlements: forcedSetts,
          sysConditions: (function() {
            let conds = [...config.system.conditions];
            conds.sort(() => Math.random() - 0.5);
            return conds.slice(0, randomInt(0, 3));
          })()
        };
      } else {
        // Distribute settlements among planets
        for (let s = 0; s < finalSettlementCount; s++) {
          let forceStation = (Math.random() < 0.05);
          let newSett = generateSettlementData(forceStation);
          let pickPlanet = randomInt(0, planets.length - 1);
          planets[pickPlanet].settlements.push(newSett);
        }
        systemData = {
          systemName,
          planets,
          settlements: null,
          sysConditions: (function() {
            let conds = [...config.system.conditions];
            conds.sort(() => Math.random() - 0.5);
            return conds.slice(0, randomInt(0, 3));
          })()
        };
      }
      renderSystem();
    }

    // Settlement Generation
    function generateSettlementData(forceStation = false, planetType = null) {
      let types = Object.values(config.settlement.types);
      let chosenType;
      if (forceStation) {
        chosenType = config.settlement.types.station;
      } else {
        chosenType = types[randomInt(0, types.length - 1)];
        if (chosenType.forceType) forceStation = true;
      }
      let pre = weightedRandom(config.names.settlementPrefix);
      let co = weightedRandom(config.names.settlementCore);
      let suf = forceStation ? { name: "Station" } : weightedRandom(config.names.settlementSuffix);
      let settlementName = pre.name + co.name + " " + suf.name;

      let mil = randomInt(config.settlement.coreStats.militarism.base.min, config.settlement.coreStats.militarism.base.max);
      let pro = randomInt(config.settlement.coreStats.prosperity.base.min, config.settlement.coreStats.prosperity.base.max);
      let sta = randomInt(config.settlement.coreStats.stability.base.min, config.settlement.coreStats.stability.base.max);
      if (planetType && planetType.modifiers) {
        mil += (planetType.modifiers.militarism || 0);
        pro += (planetType.modifiers.prosperity || 0);
        sta += (planetType.modifiers.stability || 0);
      }
      mil += chosenType.modifiers.militarism;
      pro += chosenType.modifiers.prosperity;
      sta += chosenType.modifiers.stability;
      mil = Math.max(0, Math.min(150, mil));
      pro = Math.max(0, Math.min(150, pro));
      sta = Math.max(0, Math.min(150, sta));

      let popMax = Math.floor((pro / 100) * config.globalSettings.defaultRanges.population.max * chosenType.populationMultiplier);
      if (chosenType.name === "Station" && Math.random() < 0.95) {
        popMax = Math.min(popMax, 200);
      }
      popMax = Math.max(popMax, config.globalSettings.defaultRanges.population.min);
      let population = randomInt(config.globalSettings.defaultRanges.population.min, popMax);

      // Government and ruler, using our custom functions
      let gov = pickGovernment(mil, pro, sta);
      let ruler = pickRulerTitle(mil, pro, sta);

      let firstPre = weightedRandom(config.names.firstNamePrefixes).name;
      let firstSuf = weightedRandom(config.names.firstNameSuffixes).name;
      let lastPre = weightedRandom(config.names.lastNamePrefixes).name;
      let lastSuf = weightedRandom(config.names.lastNameSuffixes).name;
      let importantFigure = ruler + " " + firstPre + firstSuf + " " + lastPre + lastSuf;

      // Exports
      let exPool;
      if (pro < 40) exPool = [...config.settlement.attributes.exports.lowProsperity];
      else if (pro < 70) exPool = [...config.settlement.attributes.exports.mediumProsperity];
      else exPool = [...config.settlement.attributes.exports.highProsperity];
      exPool.sort(() => Math.random() - 0.5);
      let exCount = randomInt(1, 5);
      let exportsArr = exPool.slice(0, exCount);

      // Points of Interest: rare (0-2)
      let poiPool;
      if (pro < 40) poiPool = [...config.settlement.attributes.pointsOfInterest.lowProsperity];
      else if (pro < 70) poiPool = [...config.settlement.attributes.pointsOfInterest.mediumProsperity];
      else poiPool = [...config.settlement.attributes.pointsOfInterest.highProsperity];
      poiPool.sort(() => Math.random() - 0.5);
      let poiCount = randomInt(0, 2);
      let poi = poiPool.slice(0, poiCount);

      // Conditions: rare (0-2)
      let condPool = [...config.settlement.conditions.settlement];
      condPool.sort(() => Math.random() - 0.5);
      let condCount = randomInt(0, 2);
      let conditions = condPool.slice(0, condCount);

      let military = generateMilitaryData(population, mil);

      // Military structures: rare (0-3)
      let structMin = config.settlement.military.structures.minCount;
      let structMax = config.settlement.military.structures.maxCount;
      let baseStructCount = randomInt(structMin, structMax);
      if (mil > 80) baseStructCount += 1;
      if (baseStructCount < 0) baseStructCount = 0;
      let sList = [...config.settlement.military.structures.structureList];
      sList.sort(() => Math.random() - 0.5);
      let militaryStructures = sList.slice(0, baseStructCount);

      // Traders
      let tMin = config.settlement.traders.defaultCountRange.min;
      let tMax = config.settlement.traders.defaultCountRange.max;
      if (sta < 30) tMax = Math.max(tMin, tMax - 1);
      else if (sta > 70) tMax = Math.min(6, tMax + 1);
      let tCount = randomInt(tMin, tMax);
      let traders = generateTraders(tCount, pro);

      return {
        name: settlementName.trim(),
        settlementType: chosenType.name,
        population,
        government: gov,
        importantFigure,
        coreStats: { militarism: mil, prosperity: pro, stability: sta },
        exports: exportsArr,
        pointsOfInterest: poi,
        conditions,
        military,
        militaryStructures,
        traders
      };
    }

    function generateMilitaryData(population, militarism) {
      let basePerc = randomInt(
        config.settlement.military.assets.soldiers.populationPercentage.min * 100,
        config.settlement.military.assets.soldiers.populationPercentage.max * 100
      ) / 100;
      let soldierMult = militarism / 50;
      let soldiers = Math.floor(population * basePerc * soldierMult);
      // Rare chance to exceed population if militarism is super high
      if (militarism > 80 && Math.random() < 0.02) {
        soldiers += randomInt(1, population);
      }
      let ratio = randomInt(
        config.settlement.military.assets.armoredVehicles.soldiersPerVehicle.min,
        config.settlement.military.assets.armoredVehicles.soldiersPerVehicle.max
      );
      let armoredVehicles = Math.max(1, Math.floor(soldiers / ratio));
      let ships = {};
      if (config.settlement.military.assets.ships.enabled) {
        let totalShips = 0;
        if (population >= config.settlement.military.assets.ships.defaultMinimumPopulation) {
          totalShips = randomInt(
            config.settlement.military.assets.ships.defaultShipCountRange.min,
            config.settlement.military.assets.ships.defaultShipCountRange.max
          );
        }
        for (let st of config.settlement.military.assets.ships.shipTypes) {
          ships[st.name] = 0;
        }
        for (let i = 0; i < totalShips; i++) {
          let chosen = weightedRandom(config.settlement.military.assets.ships.shipTypes);
          ships[chosen.name]++;
        }
      }
      return { soldiers, armoredVehicles, ships };
    }

    function generateTraders(numTraders, prosperity) {
      let out = [];
      for (let i = 0; i < numTraders; i++) {
        let specializedChance = 0.1;
        if (config.settlement.traders.specializedTraders && Math.random() < specializedChance) {
          out.push(generateSpecializedTrader());
        } else {
          out.push(generateNormalTrader(prosperity));
        }
      }
      return out;
    }

    function generateSpecializedTrader() {
      let arr = config.settlement.traders.specializedTraders;
      let total = arr.reduce((sum, x) => sum + x.rarity, 0);
      let rnd = Math.random() * total;
      for (let sp of arr) {
        if (rnd < sp.rarity) return buildSpecTrader(sp);
        rnd -= sp.rarity;
      }
      return buildSpecTrader(arr[arr.length - 1]);
    }

    function buildSpecTrader(spObj) {
      let cFirstPre = weightedRandom(config.names.firstNamePrefixes).name;
      let cFirstSuf = weightedRandom(config.names.firstNameSuffixes).name;
      let cLastPre = weightedRandom(config.names.lastNamePrefixes).name;
      let cLastSuf = weightedRandom(config.names.lastNameSuffixes).name;
      let cName = cFirstPre + cFirstSuf + " " + cLastPre + cLastSuf;
      let item = spObj.items[randomInt(0, spObj.items.length - 1)];
      return {
        captainName: cName,
        tradedMaterial: item,
        type: spObj.type,
        flavor: spObj.flavor
      };
    }

    function generateNormalTrader(prosperity) {
      let cFirstPre = weightedRandom(config.names.firstNamePrefixes).name;
      let cFirstSuf = weightedRandom(config.names.firstNameSuffixes).name;
      let cLastPre = weightedRandom(config.names.lastNamePrefixes).name;
      let cLastSuf = weightedRandom(config.names.lastNameSuffixes).name;
      let cName = cFirstPre + cFirstSuf + " " + cLastPre + cLastSuf;
      let matPool;
      if (prosperity < 40) matPool = config.extensions.traders.configuration.attributes.tradedMaterial.lowProsperity;
      else if (prosperity < 70) matPool = config.extensions.traders.configuration.attributes.tradedMaterial.mediumProsperity;
      else matPool = config.extensions.traders.configuration.attributes.tradedMaterial.highProsperity;
      let item = matPool[randomInt(0, matPool.length - 1)];
      return {
        captainName: cName,
        tradedMaterial: item
      };
    }

    function renderSettlement(sett, planetIndex, settlementIndex) {
      let shipStr = "None";
      let arr = [];
      for (let s in sett.military.ships) {
        if (sett.military.ships[s] > 0) arr.push(s + " x" + sett.military.ships[s]);
      }
      if (arr.length > 0) shipStr = arr.join(", ");
      let tradersStr = "None";
      if (sett.traders && sett.traders.length > 0) {
        tradersStr = sett.traders.map(t => t.type ? `${t.type} ${t.captainName} [${t.tradedMaterial}]` : `${t.captainName} (${t.tradedMaterial})`).join(", ");
      }
      let milStructs = sett.militaryStructures.length > 0 ? sett.militaryStructures.join(", ") : "None";
      return `
      <div class="settlement">
        <div class="settlement-output">
          <p><strong>Name:</strong> ${sett.name}</p>
          <p><strong>Type:</strong> ${sett.settlementType}</p>
          <p><strong>Population:</strong> ${sett.population}</p>
          <p><strong>Government:</strong> ${sett.government}</p>
          <p><strong>Important Figure:</strong> ${sett.importantFigure}</p>
          <p><strong>Core Stats:</strong> Militarism: ${sett.coreStats.militarism}, Prosperity: ${sett.coreStats.prosperity}, Stability: ${sett.coreStats.stability}</p>
          <p><strong>Exports:</strong> ${sett.exports.join(", ") || "None"}</p>
          <p><strong>Points of Interest:</strong> ${sett.pointsOfInterest.join(", ") || "None"}</p>
          <p><strong>Conditions:</strong> ${sett.conditions.join(", ") || "None"}</p>
          <p><strong>Military:</strong> Soldiers: ${sett.military.soldiers}, Armored Vehicles: ${sett.military.armoredVehicles}, Ships: ${shipStr}</p>
          <p><strong>Military Structures:</strong> ${milStructs}</p>
          <p><strong>Traders:</strong> ${tradersStr}</p>
        </div>
        <button onclick="regenerateSettlement(${planetIndex}, ${settlementIndex})" class="${config.ui.elements.regenerateButton.class}">
          ${config.ui.elements.regenerateButton.label}
        </button>
      </div>`;
    }

    function renderSystem() {
      const out = document.getElementById("systemOutput");
      let totalSett = 0;
      if (systemData.planets && systemData.planets.length > 0) {
        totalSett = systemData.planets.reduce((sum, pl) => sum + pl.settlements.length, 0);
      } else if (systemData.settlements) {
        totalSett = systemData.settlements.length;
      }
      let html = `
      <div class="section">
        <h2>System: ${systemData.systemName}</h2>
        <p><strong>System Conditions:</strong> ${systemData.sysConditions.join(", ") || "None"}</p>
        <p><strong>Number of Planets:</strong> ${systemData.planets ? systemData.planets.length : 0}</p>
        <p><strong>Total Settlements:</strong> ${totalSett}</p>
      </div>`;
      if (systemData.planets && systemData.planets.length > 0) {
        systemData.planets.forEach((planet, pIndex) => {
          html += `<div class="section planet">
            <h3>Planet: ${planet.name}</h3>
            <p><strong>Biome:</strong> ${planet.biome} (${planet.type ? planet.type.name : "Unknown"})</p>`;
          if (planet.settlements.length > 0) {
            planet.settlements.forEach((sett, sIndex) => {
              html += renderSettlement(sett, pIndex, sIndex);
            });
          } else {
            html += `<p>No settlements on this planet.</p>`;
          }
          html += `</div>`;
        });
      } else if (systemData.settlements) {
        systemData.settlements.forEach((sett, i) => {
          html += `<div class="section">
            <h3>Settlement (Space Station):</h3>
            ${renderSettlement(sett, 0, i)}
          </div>`;
        });
      }
      out.innerHTML = html;
    }

    function regenerateSettlement(planetIndex, settlementIndex) {
      if (systemData.planets && systemData.planets.length > 0 && systemData.planets[planetIndex]) {
        let planetType = systemData.planets[planetIndex].type;
        systemData.planets[planetIndex].settlements[settlementIndex] = generateSettlementData(false, planetType);
      } else if (systemData.settlements) {
        systemData.settlements[settlementIndex] = generateSettlementData(true);
      }
      renderSystem();
    }

    document.getElementById("generateSystemButton").addEventListener("click", generateSystem);
    loadConfig().then(() => {
      // Uncomment to auto-generate on page load:
      // generateSystem();
    });
  </script>
</body>
</html>
