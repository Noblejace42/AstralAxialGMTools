<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Emerson Neher</title>

  <!-- Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible&display=swap">
  <!-- Main Styles -->
  <link rel="stylesheet" href="home.css" />
</head>
<body>

  <!-- Center Card -->
  <div class="center-card" id="centerCard">
    <!-- Buttons Row -->
    <div class="card-buttons">
      <a href="systemgen.html" class="card-btn">Astral Axial</a>
      <a href="https://emersonneher.substack.com" target="_blank" class="card-btn">Hopeless Poetic</a>
      <a href="#" class="card-btn">Miscellaneous</a>
    </div>

    <!-- Personal Image -->
    <div class="card-image">
      <img src="image/sittingimage.jpg" alt="Emerson Neher" />
    </div>

    <!-- Contact Info -->
    <div class="contact-card">
      <h1>Emerson Neher</h1>
      <h3>they/them/theirs</h3>
      <p>Email: <a href="mailto:emersonneher@gmail.com">emersonneher@gmail.com</a></p>
      <p>Worcester, MA &amp; Evergreen, CO</p>
      <p>
        Worcester Polytechnic Institute | Class of 2028<br />
        Financial Technology Major | Information Systems Major
      </p>
      <p class="links">
        <a href="https://www.linkedin.com/in/emerson-neher-184274346" target="_blank">LinkedIn</a> |
        <a href="https://www.instagram.com/emerson.neher/" target="_blank">Instagram</a> |
        <a href="https://discord.com/users/noblejace" target="_blank">Discord</a>
      </p>
      <p class="bio">
        Passionate about technology, finance, and systems design. Iâ€™m a writer, game designer, and storyteller 
        who finds inspiration in the rhythm of poetry, the mechanics of RPGs, and the art of photography. 
        Whether crafting immersive worlds, capturing fleeting moments, or experimenting with new game systems, 
        I love exploring the intersection of creativity and experience.
      </p>
    </div>

    <!-- Smaller Spotify Embed (blue style) -->
    <div class="spotify-container">
      <h3 class="spotify-title">Currently Listening</h3>
      <iframe 
        style="border-radius:12px; width:100%;"
        src="https://open.spotify.com/embed/playlist/0FdmEAvUL4hFCzBDev8n6J?utm_source=generator&theme=1" 
        width="100%" 
        height="180" 
        frameborder="0" 
        allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
        loading="lazy">
      </iframe>
    </div>

  </div>

  <!-- Container for images on the left side -->
  <div class="tiles-container"></div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {

      /***************************************************************
       * 1) Center the card 
       ***************************************************************/
      const centerCard = document.getElementById('centerCard');
      function centerTheCard() {
        const rect = centerCard.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        // ensure some breathing room from top
        const topPos = Math.max(10, (vh - rect.height)/2);
        centerCard.style.left = (vw - rect.width)/2 + 'px';
        centerCard.style.top  = topPos + 'px';
      }
      window.addEventListener('resize', centerTheCard);
      centerTheCard();

      /***************************************************************
       * 2) Random images on the left, no overlap, varied sizes 
       ***************************************************************/
      const tilePaths = [];
      // e.g. 4..37
      for (let i = 4; i <= 37; i++) {
        tilePaths.push(`image/${i}.jpg`);
      }
      // you can add personal images if you want:
      // tilePaths.push('image/graffitibackdrop.jpg', 'image/headshotlandscape.png', ...);

      const tileData = [];
      let loadedCount = 0;

      // Preload images
      tilePaths.forEach(src => {
        const img = new Image();
        img.src = src;
        img.onload = () => {
          // store aspect ratio, etc.
          tileData.push({ src, aspect: (img.width / img.height) || 1 });
          loadedCount++;
          if (loadedCount === tilePaths.length) {
            startSpawning();
          }
        };
        img.onerror = () => {
          loadedCount++;
          if (loadedCount === tilePaths.length) {
            startSpawning();
          }
        };
      });

      const tilesContainer = document.querySelector('.tiles-container');
      // We'll track bounding boxes of placed tiles so we don't overlap
      const placedRects = [];

      function getCardRect() {
        const c = centerCard.getBoundingClientRect();
        return { left:c.left, top:c.top, right:c.right, bottom:c.bottom };
      }

      // basic overlap check
      function overlap(r1, r2){
        return !(
          r1.right < r2.left ||
          r1.left  > r2.right ||
          r1.bottom< r2.top  ||
          r1.top   > r2.bottom
        );
      }

      // Attempt to place a new tile on the left side at random coordinates
      function placeTile(tileDiv) {
        // pick random size in px (not too small)
        // e.g. between 200..400 px wide
        const minW=200, maxW=400;
        const w = minW + Math.random()*(maxW - minW);
        // scale height by aspect
        const aspect = parseFloat(tileDiv.dataset.aspect) || 1;
        const h = w / aspect;

        const vw = window.innerWidth;
        const vh = window.innerHeight;

        // We'll place them in left side: left= 0.. (vw*0.45)
        // so the card on the right is not blocked
        const maxLeft = vw * 0.45;
        for (let tries=0; tries<50; tries++){
          const left = Math.random()*(maxLeft - w);
          const top  = Math.random()*(vh - h);

          const newRect = {
            left, top,
            right: left + w,
            bottom: top + h
          };

          // check overlap with center card
          const cardR = getCardRect();
          if (overlap(newRect, cardR)) {
            continue;
          }
          // check overlap with existing placed tiles
          let conflict = false;
          for (const r of placedRects){
            if (overlap(newRect, r)) {
              conflict = true;
              break;
            }
          }
          if (conflict) continue;

          // success
          tileDiv.style.width  = w + 'px';
          tileDiv.style.height = h + 'px';
          tileDiv.style.left   = left + 'px';
          tileDiv.style.top    = top + 'px';

          placedRects.push(newRect);
          return true;
        }
        return false; // couldn't place
      }

      // Spawns a new tile from tileData
      function spawnTile() {
        // pick a random image
        const idx = Math.floor(Math.random()*tileData.length);
        const td = tileData[idx];

        // create the div
        const div = document.createElement('div');
        div.classList.add('no-overlap-tile');
        div.style.backgroundImage = `url('${td.src}')`;
        div.dataset.aspect = td.aspect;

        // try placing
        const placed = placeTile(div);
        if (placed) {
          tilesContainer.appendChild(div);
          // fade it in
          div.style.opacity = '1';
        }
      }

      // spawn a new tile every ~2 seconds
      function startSpawning() {
        // prime 5 tiles at once initially
        for (let i=0; i<5; i++){
          spawnTile();
        }
        // spawn new tile every 2s
        setInterval(spawnTile, 2000);
      }

    });
  </script>

</body>
</html>
