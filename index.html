<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Emerson Neher</title>

  <!-- Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible&display=swap">
  <!-- Main Styles -->
  <link rel="stylesheet" href="home.css" />
</head>
<body>

  <!-- Center Card -->
  <div class="center-card" id="centerCard">
    <!-- Buttons Row -->
    <div class="card-buttons">
      <a href="systemgen.html" class="card-btn">Astral Axial</a>
      <a href="https://emersonneher.substack.com" target="_blank" class="card-btn">Hopeless Poetic</a>
      <a href="#" class="card-btn">Miscellaneous</a>
    </div>

    <!-- Personal Image -->
    <div class="card-image">
      <img src="image/sittingimage.jpg" alt="Emerson Neher" />
    </div>

    <!-- Contact Info -->
    <div class="contact-card">
      <h1>Emerson Neher</h1>
      <h3>they/them/theirs</h3>
      <p>Email: <a href="mailto:emersonneher@gmail.com">emersonneher@gmail.com</a></p>
      <p>Worcester, MA &amp; Evergreen, CO</p>
      <p>
        Worcester Polytechnic Institute | Class of 2028<br />
        Financial Technology Major | Information Systems Major
      </p>
      <p class="links">
        <a href="https://www.linkedin.com/in/emerson-neher-184274346" target="_blank">LinkedIn</a> |
        <a href="https://www.instagram.com/emerson.neher/" target="_blank">Instagram</a> |
        <a href="https://discord.com/users/noblejace" target="_blank">Discord</a>
      </p>
      <p class="bio">
        Passionate about technology, finance, and systems design. Iâ€™m a writer, game designer, and storyteller 
        who finds inspiration in the rhythm of poetry, the mechanics of RPGs, and the art of photography. 
        Whether crafting immersive worlds, capturing fleeting moments, or experimenting with new game systems, 
        I love exploring the intersection of creativity and experience.
      </p>
    </div>

    <!-- Smaller Spotify Embed (blue style) -->
    <div class="spotify-container">
      <h3 class="spotify-title">Currently Listening</h3>
      <iframe 
        style="border-radius:12px; width:100%;"
        src="https://open.spotify.com/embed/playlist/0FdmEAvUL4hFCzBDev8n6J?utm_source=generator&theme=1" 
        width="100%" 
        height="180" 
        frameborder="0" 
        allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
        loading="lazy">
      </iframe>
    </div>

  </div>

  <!-- Container for moving images -->
  <div class="tiles-container"></div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {

    /***************************************************************
     * 1) Center the card 
     ***************************************************************/
    const centerCard = document.getElementById('centerCard');
    function centerTheCard() {
      const rect = centerCard.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      // ensure some breathing room from top
      const topPos = Math.max(10, (vh - rect.height)/2);
      centerCard.style.left = (vw - rect.width)/2 + 'px';
      centerCard.style.top  = topPos + 'px';
    }
    window.addEventListener('resize', centerTheCard);
    centerTheCard();

    /***************************************************************
     * 2) Load images 
     ***************************************************************/
    const tilePaths = [];
    for (let i=4; i<=37; i++){
      tilePaths.push(`image/${i}.jpg`);
    }
    // Add personal images if desired
    // tilePaths.push('image/graffitibackdrop.jpg','image/headshotlandscape.png',...);

    let loadedCount=0;
    const tileData=[];

    tilePaths.forEach(src=>{
      const img = new Image();
      img.src=src;
      img.onload=()=>{
        tileData.push({
          src, aspect: (img.width/img.height)||1
        });
        loadedCount++;
        if(loadedCount===tilePaths.length) startSpawning();
      };
      img.onerror=()=>{
        loadedCount++;
        if(loadedCount===tilePaths.length) startSpawning();
      };
    });

    const tilesContainer = document.querySelector('.tiles-container');
    // store bounding rects to prevent overlap
    const placedRects=[];

    function getCardRect() {
      const c = centerCard.getBoundingClientRect();
      return { left:c.left, top:c.top, right:c.right, bottom:c.bottom };
    }
    function overlap(r1, r2) {
      return !(
        r1.right<r2.left ||
        r1.left>r2.right  ||
        r1.bottom<r2.top  ||
        r1.top>r2.bottom
      );
    }

    // spawn images from left to right, moving at a certain speed
    // with random vertical position, random size, no overlap
    let spawnInterval;
    function startSpawning() {
      // spawn an initial set
      for (let i=0; i<5; i++){
        spawnImage();
      }
      spawnInterval = setInterval(spawnImage, 3000); // new image every 3s
    }

    function spawnImage() {
      if(!tileData.length) return;
      // pick a random image
      const td = tileData[Math.floor(Math.random()*tileData.length)];

      const div = document.createElement('div');
      div.classList.add('moving-tile');
      div.dataset.aspect = td.aspect;
      div.style.backgroundImage = `url('${td.src}')`;

      // pick random width from 150..350
      const minW=150, maxW=350;
      const w = minW + Math.random()*(maxW-minW);
      const h = w / td.aspect;

      // find non-overlapping top if possible
      const vh = window.innerHeight, vw=window.innerWidth;
      // initial left is negative (offscreen to the left)
      const initialLeft = - (w + 50);
      for(let tries=0; tries<50; tries++){
        const top = Math.random()*(vh - h);

        // construct newRect
        const newRect = { left: initialLeft, top, right: initialLeft+w, bottom: top+h };

        // check overlap with card
        if(overlap(newRect, getCardRect())) continue;
        // check overlap with existing tiles
        let conflict=false;
        for(const r of placedRects){
          if(overlap(newRect,r)){ conflict=true; break; }
        }
        if(conflict) continue;

        // success
        div.style.width  = w+'px';
        div.style.height = h+'px';
        div.style.left   = initialLeft+'px';
        div.style.top    = top+'px';
        tilesContainer.appendChild(div);
        placedRects.push(newRect);

        // animate it across using a requestAnimationFrame loop
        moveTile(div, newRect);
        return; 
      }
      // if can't place, skip
    }

    function moveTile(div, rect) {
      // each tile moves at e.g. 30 px/s
      const speed=30; 
      const frameTime=16; // ~60fps
      function animate() {
        // update rect
        rect.left += (speed*(frameTime/1000));
        rect.right= rect.left + parseFloat(div.style.width);
        // apply transform
        div.style.left= rect.left+'px';

        // if it's off the right edge
        if(rect.left> window.innerWidth+30) {
          // remove from DOM, remove from placedRects
          tilesContainer.removeChild(div);
          const idx=placedRects.indexOf(rect);
          if(idx>=0) placedRects.splice(idx,1);
          return;
        }
        // otherwise, keep animating
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    }

  });
  </script>

</body>
</html>
