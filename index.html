<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Astral Axial System Generator</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <nav>
    <a href="index.html">System Generator</a> |
    <a href="lifepath.html">Lifepath Generator</a> |
    <a href="weapongenerator.html">Weapon Generator</a> |
    <a href="combat_tracker.html">Combat Tracker</a>
  </nav>

  <div class="container">
    <h1>Astral Axial System Generator</h1>
    <!-- Main output container where the system and settlements will be rendered -->
    <div id="systemOutput"></div>
    <!-- Button to generate a new system -->
    <button id="generateSystemButton" class="btn-system">
      Generate System
    </button>
    <!-- Advanced options panel (collapsible/hidden for now) -->
    <div id="advancedOptions" style="display: none;">
      <h2>Advanced Settings</h2>
      <!-- Future dynamic UI elements can be injected here -->
    </div>
  </div>

  <div class="art-credit">
    <a href="https://www.instagram.com/vinny.longbow?igsh=c203czNuMW92MXA3" target="_blank">
      Art Credit: Vincent Fleetwood
    </a>
  </div>

  <script>
    // Global variables to hold the configuration and generated system data.
    let config = null;
    let systemData = null;

    // Utility Functions
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function weightedRandom(choices) {
      const totalWeight = choices.reduce((sum, choice) => sum + choice.weight, 0);
      let randomNum = Math.random() * totalWeight;
      for (const choice of choices) {
        if (randomNum < choice.weight) {
          return choice.value !== undefined ? choice.value : choice.name;
        }
        randomNum -= choice.weight;
      }
    }

    // Convert an integer (1â€“10) to a Roman numeral.
    function toRoman(num) {
      const romans = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"];
      return romans[num - 1] || num;
    }

    // Fetch the external configuration JSON file.
    async function loadConfig() {
      try {
        const response = await fetch('systemgeneratorinfo.json');
        config = await response.json();
        console.log('Config loaded:', config);
      } catch (error) {
        console.error('Failed to load config:', error);
      }
    }

    // --- System Generation Functions ---
    function generateSystemCode() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const digits = "0123456789";
      let code = "";
      // Using the "LLDDLD" pattern: two letters, two digits, one letter, one digit.
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      return code;
    }

    function generateSystem() {
      // Generate system code and designation.
      let code = generateSystemCode();
      let prefix = weightedRandom(config.system.nameComponents.prefix);
      let core = weightedRandom(config.system.nameComponents.core);
      let systemDesignation = prefix + core;
      let systemName = code + " " + systemDesignation;

      // Fallback for planetCountRange if not provided.
      const planetCountRange = config.system.planetCountRange || { min: 0, max: 6 };
      let numPlanets = randomInt(planetCountRange.min, planetCountRange.max);
      let planets = [];
      if (numPlanets > 0) {
        for (let i = 1; i <= numPlanets; i++) {
          // Choose a random planet type.
          let planetType = weightedRandom(config.planet.types);
          // Choose a planetary biome from planet conditions.
          let biome = config.planet.conditions[randomInt(0, config.planet.conditions.length - 1)];
          let planetName = systemDesignation + " " + toRoman(i);
          let planet = {
            name: planetName,
            biome: biome,
            type: planetType,
            settlements: []
          };
          // Generate between 1 and 4 settlements for this planet.
          let settlementCount = randomInt(1, 4);
          for (let j = 0; j < settlementCount; j++) {
            planet.settlements.push(generateSettlementData(false, planetType));
          }
          planets.push(planet);
        }
      }

      // If no planets are generated, create a standalone settlement.
      let settlements = [];
      if (numPlanets === 0) {
        settlements.push(generateSettlementData(true));
      }

      // Choose system conditions (up to 3).
      let sysConditions = config.system.conditions.sort(() => Math.random() - 0.5)
                        .slice(0, randomInt(0, 3));

      systemData = {
        systemName: systemName,
        planets: planets,
        settlements: numPlanets === 0 ? settlements : null,
        sysConditions: sysConditions
      };

      renderSystem();
    }

    // --- Settlement Generation Functions ---
    function generateSettlementData(forceType = false, planetModifier = null) {
      // Choose settlement type.
      let settlementType;
      if (forceType) {
        settlementType = config.settlement.settlementTypes.station;
      } else {
        const types = Object.values(config.settlement.settlementTypes);
        settlementType = types[randomInt(0, types.length - 1)];
        if (settlementType.forceType) forceType = true;
      }

      // Generate the settlement name.
      let prefix = weightedRandom(config.names.settlementPrefix);
      let core = weightedRandom(config.names.settlementCore);
      let suffix = (forceType && settlementType.forceType) ? settlementType.name : weightedRandom(config.names.settlementSuffix);
      let name = prefix + core + " " + suffix;

      // Generate core stats.
      let militarism = randomInt(config.settlement.coreStats.militarism.base.min, config.settlement.coreStats.militarism.base.max);
      let prosperity = randomInt(config.settlement.coreStats.prosperity.base.min, config.settlement.coreStats.prosperity.base.max);
      let stability = randomInt(config.settlement.coreStats.stability.base.min, config.settlement.coreStats.stability.base.max);

      // Apply planet modifiers if present.
      if (planetModifier && planetModifier.modifiers) {
        militarism += planetModifier.modifiers.militarism || 0;
        prosperity += planetModifier.modifiers.prosperity || 0;
        stability += planetModifier.modifiers.stability || 0;
      }
      // Clamp stats.
      militarism = Math.max(0, Math.min(militarism, 150));
      prosperity = Math.max(0, Math.min(prosperity, 150));
      stability = Math.max(0, Math.min(stability, 150));

      // Population is based on prosperity, global max, and settlement type multiplier.
      let popMax = Math.floor((prosperity / 100) * config.globalSettings.defaultRanges.population.max * settlementType.populationMultiplier);
      popMax = Math.max(popMax, config.globalSettings.defaultRanges.population.min);
      let population = randomInt(config.globalSettings.defaultRanges.population.min, popMax);

      // Government and ruler.
      let government = weightedRandom(config.settlement.government.types);
      let rulerTitle = weightedRandom(config.settlement.government.rulerTitles);

      // Important figure.
      let firstName = weightedRandom(config.names.firstNamePrefixes) + weightedRandom(config.names.firstNameSuffixes);
      let lastName = weightedRandom(config.names.lastNamePrefixes) + weightedRandom(config.names.lastNameSuffixes);
      let importantFigure = rulerTitle + " " + firstName + " " + lastName;

      // Exports based on prosperity thresholds.
      let exportsPool = [];
      if (prosperity < 40) {
        exportsPool = config.settlement.attributes.exports.lowProsperity;
      } else if (prosperity < 70) {
        exportsPool = config.settlement.attributes.exports.mediumProsperity;
      } else {
        exportsPool = config.settlement.attributes.exports.highProsperity;
      }
      let expCount = randomInt(1, 5);
      let exportsGenerated = exportsPool.sort(() => Math.random() - 0.5).slice(0, expCount);

      // Points of Interest based on prosperity.
      let poiPool = [];
      if (prosperity < 40) {
        poiPool = config.settlement.attributes.pointsOfInterest.lowProsperity;
      } else if (prosperity < 70) {
        poiPool = config.settlement.attributes.pointsOfInterest.mediumProsperity;
      } else {
        poiPool = config.settlement.attributes.pointsOfInterest.highProsperity;
      }
      let poiCount = randomInt(1, poiPool.length);
      let poi = poiPool.sort(() => Math.random() - 0.5).slice(0, poiCount);

      // Settlement conditions.
      let conds = config.settlement.conditions.settlement.sort(() => Math.random() - 0.5)
                 .slice(0, randomInt(0, 3));

      // Military assets.
      let military = generateMilitaryData(population, militarism, forceType);

      // Military structures: count influenced by militarism.
      let baseStructCount = randomInt(config.settlement.military.structures.minCount, config.settlement.military.structures.maxCount);
      if (militarism > 70) baseStructCount += 2;
      else if (militarism < 40) baseStructCount = Math.max(1, baseStructCount - 1);
      let militaryStructures = [];
      let structuresList = config.settlement.military.structures.structureList;
      for (let i = 0; i < baseStructCount; i++) {
        militaryStructures.push(structuresList[randomInt(0, structuresList.length - 1)]);
      }

      // Traders: number determined by prosperity and modified by stability.
      const settlementTraderOptions = config.system.settlementCountOptions || [
        { value: 0, weight: 3 },
        { value: 1, weight: 3 },
        { value: 2, weight: 3 },
        { value: 3, weight: 3 },
        { value: 4, weight: 1 },
        { value: 5, weight: 1 },
        { value: 6, weight: 1 },
        { value: 7, weight: 1 },
        { value: 8, weight: 1 },
        { value: 9, weight: 1 },
        { value: 10, weight: 1 }
      ];
      let traderMin = config.settlement.traders.defaultCountRange.min;
      let traderMax = config.settlement.traders.defaultCountRange.max;
      if (stability < 40) traderMax = Math.max(traderMin, traderMax - 1);
      else if (stability > 70) traderMax = Math.min(6, traderMax + 1);
      let traderCount = randomInt(traderMin, traderMax);
      let traders = [];
      let tradedMaterialsPool = [];
      if (prosperity < 40) {
        tradedMaterialsPool = config.extensions.traders.configuration.attributes.tradedMaterial.lowProsperity;
      } else if (prosperity < 70) {
        tradedMaterialsPool = config.extensions.traders.configuration.attributes.tradedMaterial.mediumProsperity;
      } else {
        tradedMaterialsPool = config.extensions.traders.configuration.attributes.tradedMaterial.highProsperity;
      }
      for (let i = 0; i < traderCount; i++) {
        let captainFirstName = weightedRandom(config.names.firstNamePrefixes) + weightedRandom(config.names.firstNameSuffixes);
        let captainLastName = weightedRandom(config.names.lastNamePrefixes) + weightedRandom(config.names.lastNameSuffixes);
        let captainName = captainFirstName + " " + captainLastName;
        let tradedMaterial = tradedMaterialsPool[randomInt(0, tradedMaterialsPool.length - 1)];
        traders.push({
          captainName,
          tradedMaterial
        });
      }

      return {
        name,
        population,
        government,
        importantFigure,
        coreStats: { militarism, prosperity, stability },
        exports: exportsGenerated,
        conditions: conds,
        pointsOfInterest: poi,
        military: military,
        militaryStructures: militaryStructures,
        traders: traders,
        settlementType: settlementType.name
      };
    }

    function generateMilitaryData(population, militarism, forcedStation) {
      // Calculate soldier count using a base percentage modified by militarism.
      let basePerc = randomInt(config.settlement.military.assets.soldiers.populationPercentage.min * 100,
                                 config.settlement.military.assets.soldiers.populationPercentage.max * 100) / 100;
      let soldierMultiplier = militarism / 50; // Factor of 1 when militarism = 50.
      let soldiers = Math.floor(population * basePerc * soldierMultiplier);

      // Armored vehicles determined by dividing soldier count by a random ratio.
      let vehiclesRatio = randomInt(config.settlement.military.armoredVehicles.soldiersPerVehicle.min,
                                    config.settlement.military.armoredVehicles.soldiersPerVehicle.max);
      let armoredVehicles = Math.max(1, Math.floor(soldiers / vehiclesRatio));

      let ships = {};
      if (config.settlement.military.assets.ships.enabled) {
        let totalShips = 0;
        if (forcedStation) {
          totalShips = randomInt(config.settlement.military.assets.ships.forcedStationMinimum.min,
                                 config.settlement.military.assets.ships.forcedStationMinimum.max);
        } else if (population >= config.settlement.military.assets.ships.defaultMinimumPopulation) {
          totalShips = randomInt(config.settlement.military.assets.ships.defaultShipCountRange.min,
                                 config.settlement.military.assets.ships.defaultShipCountRange.max);
        }
        config.settlement.military.assets.ships.shipTypes.forEach(shipType => {
          ships[shipType.name] = 0;
        });
        for (let i = 0; i < totalShips; i++) {
          let chosenType = weightedRandom(config.settlement.military.assets.ships.shipTypes);
          ships[chosenType.name] += 1;
        }
      }
      return { soldiers, armoredVehicles, ships };
    }

    // --- Rendering Functions ---
    function renderSettlement(settlement, planetIndex, settlementIndex) {
      let shipStr = "";
      if (settlement.military.ships) {
        for (let type in settlement.military.ships) {
          if (settlement.military.ships[type] > 0) {
            shipStr += `${type} x${settlement.military.ships[type]} `;
          }
        }
      }
      if (shipStr === "") shipStr = "None";

      // Render traders.
      let tradersHtml = "";
      if (settlement.traders && settlement.traders.length > 0) {
        tradersHtml = `<ul>`;
        settlement.traders.forEach(trader => {
          tradersHtml += `<li>${trader.captainName} trading ${trader.tradedMaterial}</li>`;
        });
        tradersHtml += `</ul>`;
      }

      // Render military structures.
      let militaryStructuresHtml = "";
      if (settlement.militaryStructures && settlement.militaryStructures.length > 0) {
        militaryStructuresHtml = `<ul>`;
        settlement.militaryStructures.forEach(structure => {
          militaryStructuresHtml += `<li>${structure}</li>`;
        });
        militaryStructuresHtml += `</ul>`;
      }

      return `
      <div class="settlement" id="settlement-${planetIndex}-${settlementIndex}">
        <div class="settlement-output">
          <strong>Name:</strong> ${settlement.name} <br>
          <strong>Type:</strong> ${settlement.settlementType} <br>
          <strong>Population:</strong> ${settlement.population} <br>
          <strong>Government:</strong> ${settlement.government} <br>
          <strong>Important Figure:</strong> ${settlement.importantFigure} <br>
          <strong>Core Stats:</strong> Militarism: ${settlement.coreStats.militarism}, Prosperity: ${settlement.coreStats.prosperity}, Stability: ${settlement.coreStats.stability} <br>
          <strong>Exports:</strong> ${settlement.exports.join(", ") || "None"} <br>
          <strong>Points of Interest:</strong> ${settlement.pointsOfInterest.join(", ") || "None"} <br>
          <strong>Conditions:</strong> ${settlement.conditions.join(", ") || "None"} <br>
          <strong>Military:</strong> Soldiers: ${settlement.military.soldiers}, Armored Vehicles: ${settlement.military.armoredVehicles}, Ships: ${shipStr} <br>
          <strong>Military Structures:</strong> ${militaryStructuresHtml || "None"} <br>
          <strong>Traders:</strong> ${tradersHtml || "None"}
        </div>
        <button onclick="regenerateSettlement(${planetIndex}, ${settlementIndex})" class="${config.ui.elements.regenerateButton.class}">
          ${config.ui.elements.regenerateButton.label}
        </button>
      </div>`;
    }

    function renderSystem() {
      const outputDiv = document.getElementById("systemOutput");
      let totalSettlements = systemData.planets.length > 0
          ? systemData.planets.reduce((sum, p) => sum + p.settlements.length, 0)
          : systemData.settlements.length;
      let html = `<div class="section">
        <h2>System: ${systemData.systemName}</h2>
        <p><strong>System Conditions:</strong> ${systemData.sysConditions.join(", ") || "None"}</p>
        <p><strong>Number of Planets:</strong> ${systemData.planets.length}</p>
        <p><strong>Total Settlements:</strong> ${totalSettlements}</p>
      </div>`;

      if (systemData.planets.length > 0) {
        systemData.planets.forEach((planet, pIndex) => {
          html += `<div class="section planet">
            <h3>Planet: ${planet.name}</h3>
            <p><strong>Biome:</strong> ${planet.biome} (${planet.type.name})</p>`;
          if (planet.settlements.length > 0) {
            planet.settlements.forEach((settlement, sIndex) => {
              html += renderSettlement(settlement, pIndex, sIndex);
            });
          } else {
            html += `<p>No settlements on this planet.</p>`;
          }
          html += `</div>`;
        });
      } else {
        html += `<div class="section">
          <h3>Settlement (Space Station):</h3>
          ${renderSettlement(systemData.settlements[0], 0, 0)}
        </div>`;
      }
      outputDiv.innerHTML = html;
    }

    function regenerateSettlement(planetIndex, settlementIndex) {
      if (systemData.planets && systemData.planets.length > 0) {
        let planet = systemData.planets[planetIndex];
        // Pass planet.type as modifier.
        planet.settlements[settlementIndex] = generateSettlementData(false, planet.type);
        renderSystem();
      } else {
        systemData.settlements[settlementIndex] = generateSettlementData(true);
        renderSystem();
      }
    }

    // --- Event Listeners ---
    document.getElementById("generateSystemButton").addEventListener("click", generateSystem);

    // Initial load: fetch configuration then wait for user interaction.
    loadConfig().then(() => {
      // Uncomment the following line to auto-generate a system on load:
     generateSystem();
    });
  </script>
</body>
</html>
