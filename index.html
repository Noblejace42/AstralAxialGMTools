<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Existential System Generator</title>
  <style>
    /* Simple retro hard sci‑fi vibe */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
    body {
      font-family: 'Orbitron', sans-serif;
      background-color: #1a1a1a;
      color: #ccc;
      margin: 0;
      padding: 20px;
      line-height: 1.5;
    }
    h1, h2, h3 {
      margin: 0.5em 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      background: #262626;
      border: 1px solid #444;
      border-radius: 4px;
    }
    .section {
      margin-bottom: 1.5em;
      padding-bottom: 1em;
      border-bottom: 1px solid #444;
    }
    button {
      background-color: #444;
      color: #ccc;
      border: 1px solid #555;
      padding: 6px 12px;
      font-size: 0.9em;
      cursor: pointer;
      border-radius: 3px;
      margin-top: 5px;
    }
    button:hover {
      background-color: #555;
    }
    .settlement, .planet {
      margin: 0.5em 0;
      padding: 0.5em;
      background: #333;
      border: 1px solid #444;
      border-radius: 3px;
    }
    .settlement-output {
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Existential System Generator</h1>
    <button onclick="generateSystem()">Generate System</button>
    <div id="systemOutput"></div>
  </div>

  <script>
    // --- Helper Functions ---
    function weightedRandom(choices) {
      let totalWeight = choices.reduce((sum, choice) => sum + choice.weight, 0);
      let randomNum = Math.random() * totalWeight;
      for (let choice of choices) {
        if (randomNum < choice.weight) {
          return choice.value !== undefined ? choice.value : choice.name;
        }
        randomNum -= choice.weight;
      }
    }
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    // Simple weighted random for numbers using an array of objects
    function weightedNumber(options) {
      return weightedRandom(options);
    }
    // Convert integer 1-6 to roman numeral
    function toRoman(num) {
      const romans = ["I", "II", "III", "IV", "V", "VI"];
      return romans[num - 1] || num;
    }
    // Generate a random alphanumeric code (like "AX11B2")
    function generateSystemCode() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const digits = "0123456789";
      let code = "";
      // For example: 2 letters, 2 digits, 1 letter, 1 digit
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      code += letters.charAt(randomInt(0, letters.length - 1));
      code += digits.charAt(randomInt(0, digits.length - 1));
      return code;
    }

    // --- Data Definitions ---

    // Reuse settlement naming arrays from previous generator.
    const settlementPrefix = [
      { name: "Cor", weight: 1 }, { name: "Ald", weight: 1 },
      { name: "Nab", weight: 1 }, { name: "Tar", weight: 1 },
      { name: "Ven", weight: 1 }, { name: "Lor", weight: 1 },
      { name: "Ryl", weight: 1 }, { name: "Mar", weight: 1 },
      { name: "Dorn", weight: 1 }, { name: "Kess", weight: 1 },
      { name: "Vel", weight: 1 }, { name: "Kael", weight: 1 },
      { name: "Ord", weight: 1 }, { name: "Mal", weight: 1 },
      { name: "Jed", weight: 1 }, { name: "Exo", weight: 1 },
      { name: "Vax", weight: 1 }, { name: "Brin", weight: 1 },
      { name: "Zor", weight: 1 }, { name: "Hoth", weight: 1 }
    ];
    const settlementCore = [
      { name: "anta", weight: 1 }, { name: "osis", weight: 1 },
      { name: "ar", weight: 1 }, { name: "osa", weight: 1 },
      { name: "ion", weight: 1 }, { name: "oran", weight: 1 },
      { name: "is", weight: 1 }, { name: "endra", weight: 1 },
      { name: "era", weight: 1 }, { name: "elis", weight: 1 },
      { name: "eta", weight: 1 }, { name: "ora", weight: 1 },
      { name: "ander", weight: 1 }, { name: "ulia", weight: 1 },
      { name: "onis", weight: 1 }
    ];
    const settlementSuffix = [
      { name: "Prime", weight: 1 },
      { name: "Major", weight: 1 },
      { name: "Minor", weight: 1 },
      { name: "Outpost", weight: 1 },
      { name: "Spire", weight: 1 },
      { name: "Haven", weight: 1 },
      { name: "Hold", weight: 1 },
      { name: "Reach", weight: 1 },
      { name: "Gate", weight: 1 },
      { name: "Basin", weight: 1 },
      { name: "Stronghold", weight: 1 },
      { name: "Station", weight: 1 },
      { name: "Anchorage", weight: 1 },
      { name: "Post", weight: 1 },
      { name: "Verge", weight: 1 },
      { name: "I", weight: 1 },
      { name: "II", weight: 1 },
      { name: "", weight: 10 },  // Favor no numeral suffix
      { name: "III", weight: 1 },
      { name: "IV", weight: 1 }
    ];
    // Development levels 1–10 (lower numbers are more common)
    const developmentLevels = [];
    for (let i = 1; i <= 10; i++) {
      developmentLevels.push({ value: i, weight: 11 - i });
    }
    // Government types
    const governments = [
      { name: "Democratic Colony", weight: 3 },
      { name: "Corporate Oligarchy", weight: 4 },
      { name: "Military Junta", weight: 2 },
      { name: "Technocratic Council", weight: 3 },
      { name: "Feudal Dominion", weight: 2 },
      { name: "Anarchic Commune", weight: 1 },
      { name: "Bureaucratic State", weight: 2 },
      { name: "Dictatorial Regime", weight: 1 }
    ];
    // Important figure name parts
    const jobTitles = [
      { name: "Governor", weight: 3 },
      { name: "Commander", weight: 2 },
      { name: "Overseer", weight: 2 },
      { name: "Chancellor", weight: 1 },
      { name: "Director", weight: 2 },
      { name: "Custodian", weight: 1 }
    ];
    const firstNamePrefixes = [
      { name: "Xan", weight: 1 },
      { name: "Tal", weight: 1 },
      { name: "Ver", weight: 1 },
      { name: "Mar", weight: 1 },
      { name: "Sel", weight: 1 }
    ];
    const firstNameSuffixes = [
      { name: "dor", weight: 1 },
      { name: "en", weight: 1 },
      { name: "ix", weight: 1 },
      { name: "ar", weight: 1 },
      { name: "os", weight: 1 }
    ];
    const lastNamePrefixes = [
      { name: "Kry", weight: 1 },
      { name: "Zan", weight: 1 },
      { name: "Mor", weight: 1 },
      { name: "Rex", weight: 1 },
      { name: "Fen", weight: 1 }
    ];
    const lastNameSuffixes = [
      { name: "ton", weight: 1 },
      { name: "sen", weight: 1 },
      { name: "dell", weight: 1 },
      { name: "", weight: 2 },
      { name: "ward", weight: 1 }
    ];
    // Exports – two sets based on development
    const lowDevExports = [
      "Raw Ore",
      "Basic Agricultural Produce",
      "Scrap Metal",
      "Water",
      "Simple Textiles"
    ];
    const highDevExports = [
      "Solar Panels",
      "Synth-Food",
      "Advanced Electronics",
      "Nanomaterials",
      "Renewable Energy Components",
      "Robotics"
    ];
    // Settlement conditions
    const settlementConditions = [
      "Occupied by a mysterious cult",
      "Blockaded by rival factions",
      "Under strict quarantine",
      "Experiencing unusual temporal distortions",
      "Haunted by echoes of the past",
      "Infested with rogue AI",
      "Subject to bizarre cosmic phenomena"
    ];
    // Points of interest (for settlements)
    const poiSettlement = [
      "Orbital Trade Station",
      "Shipyard",
      "Black Market",
      "Bounty Center",
      "Cybernetic Research Lab",
      "Interstellar Museum",
      "Abandoned Dock",
      "Mystery Archive",
      "Temporal Observatory",
      "Void Beacon"
    ];
    // --- System-Specific Data ---
    // System Conditions (for the entire system)
    const systemConditionsList = [
      "Asteroid Belt",
      "Mining Stations",
      "Binary Star",
      "Nebula",
      "Spatial Anomaly",
      "Rogue Comet"
    ];
    // Planet biomes
    const planetBiomes = [
      "Desert World",
      "Lush World",
      "Volcanic World",
      "Temperate World",
      "Ocean World",
      "Ice World",
      "Barren World"
    ];

    // --- Settlement Generation Function ---
    // forcedStation: if true, override suffix to "Station"
    function generateSettlementData(forcedStation = false) {
      const prefix = weightedRandom(settlementPrefix);
      const core = weightedRandom(settlementCore);
      let suffix;
      if (forcedStation) {
        suffix = "Station";
      } else {
        suffix = weightedRandom(settlementSuffix);
      }
      const name = prefix + core + " " + suffix;
      const development = weightedRandom(developmentLevels);
      const isStation = (suffix === "Station");
      const maxPop = isStation ? 100 : Math.min(1000 * development, 10000);
      const population = randomInt(20, maxPop);
      const government = weightedRandom(governments);
      const jobTitle = weightedRandom(jobTitles);
      const firstName = weightedRandom(firstNamePrefixes) + weightedRandom(firstNameSuffixes);
      const lastName = weightedRandom(lastNamePrefixes) + weightedRandom(lastNameSuffixes);
      const importantFigure = `${jobTitle} ${firstName} ${lastName}`;
      const exportCount = randomInt(1, 5);
      const exportsPool = (development <= 5 ? lowDevExports.slice() : highDevExports.slice());
      exportsPool.sort(() => Math.random() - 0.5);
      const exportsGenerated = exportsPool.slice(0, exportCount);
      const condCount = randomInt(0, 3);
      let conds = settlementConditions.slice().sort(() => Math.random() - 0.5).slice(0, condCount);
      const poiCount = randomInt(0, 5);
      let poi = poiSettlement.slice().sort(() => Math.random() - 0.5).slice(0, poiCount);

      return {
        name,
        development,
        population,
        government,
        importantFigure,
        exports: exportsGenerated,
        conditions: conds,
        pointsOfInterest: poi
      };
    }

    // Render a settlement's details along with its own "Regenerate Settlement" button.
    // The callback receives the planet index and the settlement index.
    function renderSettlement(settlement, planetIndex, settlementIndex) {
      return `<div class="settlement" id="settlement-${planetIndex}-${settlementIndex}">
  <div class="settlement-output">
    [Name] ${settlement.name}
    Development: ${settlement.development}
    Population: ${settlement.population}
    Government: ${settlement.government}
    Important Figure: ${settlement.importantFigure}
    Exports: ${settlement.exports.join(", ") || "None"}
    Conditions: ${settlement.conditions.join(", ") || "None"}
    Points of Interest: ${settlement.pointsOfInterest.join(", ") || "None"}
  </div>
  <button onclick="regenerateSettlement(${planetIndex}, ${settlementIndex})">Regenerate Settlement</button>
</div>`;
    }

    // --- Global System Data ---
    let systemData = null;

    // --- Generate the entire system ---
    function generateSystem() {
      // Generate system code and designation.
      const code = generateSystemCode();
      // For system designation, use a simple combination from settlementPrefix & settlementCore.
      const sysDesignation = weightedRandom(settlementPrefix) + weightedRandom(settlementCore);
      const systemName = code + " " + sysDesignation;

      // Number of planets: 0-6
      const numPlanets = randomInt(0, 6);
      // If there are planets, generate them with names "sysDesignation I", "sysDesignation II", etc.
      let planets = [];
      if (numPlanets > 0) {
        for (let i = 1; i <= numPlanets; i++) {
          const biome = planetBiomes[randomInt(0, planetBiomes.length - 1)];
          planets.push({ 
            name: sysDesignation + " " + toRoman(i),
            biome,
            settlements: [] 
          });
        }
      }
      // Number of settlements: 0-10 with more than 3 being super unlikely.
      // Create weighted options: values 0-3 with weight 3, 4-10 with weight 1.
      const settlementOptions = [];
      for (let i = 0; i <= 10; i++) {
        settlementOptions.push({ value: i, weight: (i <= 3 ? 3 : 1) });
      }
      let numSettlements = weightedRandom(settlementOptions);
      // Special case: if no planets then force a single settlement with Station suffix.
      let forcedStation = false;
      if (numPlanets === 0) {
        numSettlements = 1;
        forcedStation = true;
      }

      // Generate settlements
      let settlements = [];
      for (let i = 0; i < numSettlements; i++) {
        settlements.push(generateSettlementData(forcedStation));
      }
      // If there are planets, randomly assign each settlement to one of them.
      if (numPlanets > 0) {
        // Clear any existing settlements from each planet.
        planets.forEach(planet => planet.settlements = []);
        settlements.forEach(s => {
          const idx = randomInt(0, numPlanets - 1);
          planets[idx].settlements.push(s);
        });
      }

      // System conditions: 0-3 chosen from systemConditionsList.
      const sysCondCount = randomInt(0, 3);
      let sysConditions = systemConditionsList.slice().sort(() => Math.random() - 0.5).slice(0, sysCondCount);

      // Store the system data globally.
      systemData = {
        systemName,
        planets, // may be empty if numPlanets is 0.
        settlements: numPlanets === 0 ? settlements : null,
        sysConditions
      };

      renderSystem();
    }

    // Render the entire system to #systemOutput.
    function renderSystem() {
      const outputDiv = document.getElementById("systemOutput");
      let html = `<div class="section">
  <h2>System: ${systemData.systemName}</h2>
  <p><strong>System Conditions:</strong> ${systemData.sysConditions.join(", ") || "None"}</p>
  <p><strong>Number of Planets:</strong> ${systemData.planets.length}</p>
  <p><strong>Number of Settlements:</strong> ${systemData.planets.length > 0 
      ? systemData.planets.reduce((sum, p) => sum + p.settlements.length, 0)
      : systemData.settlements.length}</p>
</div>`;

      // If there are planets, list each planet with its settlements.
      if (systemData.planets.length > 0) {
        systemData.planets.forEach((planet, pIndex) => {
          html += `<div class="section planet">
  <h3>Planet: ${planet.name}</h3>
  <p><strong>Biome:</strong> ${planet.biome}</p>`;
          if (planet.settlements.length > 0) {
            planet.settlements.forEach((settlement, sIndex) => {
              html += renderSettlement(settlement, pIndex, sIndex);
            });
          } else {
            html += `<p>No settlements on this planet.</p>`;
          }
          html += `</div>`;
        });
      } else {
        // No planets: list the single settlement.
        html += `<div class="section">
  <h3>Settlement (Space Station):</h3>
  ${renderSettlement(systemData.settlements[0], 0, 0)}
</div>`;
      }

      outputDiv.innerHTML = html;
    }

    // Regenerate an individual settlement (for a given planet and settlement index).
    function regenerateSettlement(planetIndex, settlementIndex) {
      // Determine if system has planets or is station-only.
      if (systemData.planets.length > 0) {
        // Regenerate settlement data for that settlement.
        systemData.planets[planetIndex].settlements[settlementIndex] = generateSettlementData();
        // Re-render only that planet’s section.
        renderSystem();
      } else {
        systemData.settlements[settlementIndex] = generateSettlementData(true);
        renderSystem();
      }
    }
  </script>
</body>
</html>
