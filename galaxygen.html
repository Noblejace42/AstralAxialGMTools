<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Astral Axial Galaxy Generator</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Force a black background, removing starry image */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000 !important; /* Solid black */
        color: #ccc;
        font-family: 'Orbitron', sans-serif;
      }
      /* Top bar holds nav + controls. We don't fix it; we let the layout flow. */
      #topBar {
        width: 100%;
        background: #222; /* or #1a1a1a, adjust as needed */
        padding: 5px;
        box-sizing: border-box;
      }
      #navContainer {
        /* Nav will be loaded here. You can style as needed. */
      }
      .controls {
        margin-top: 5px;
        text-align: center;
      }

      /* Main layout: flex container with canvas on the left, sidebar on the right. */
      #mainContainer {
        display: flex;
        flex-direction: row;
        width: 100%;
        height: calc(100% - 120px); /* subtract topBar's approximate height */
        box-sizing: border-box;
      }

      /* Sidebar fixed width on the right */
      #sidebar {
        width: 400px;
        background: #262626;
        border-left: 1px solid #444;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }

      /* Canvas container on the left, fills remaining space */
      #canvasContainer {
        flex: 1; 
        position: relative;
        overflow: hidden;
      }

      /* The actual canvas fills its container */
      #galaxyCanvas {
        width: 100%;
        height: 100%;
        background: #000;
        cursor: grab;
        display: block;
      }
      #galaxyCanvas:active {
        cursor: grabbing;
      }

      /* Make sure textareas don't propagate wheel events to the canvas */
      textarea {
        width: 100%;
        background: #1a1a1a;
        color: #ddd;
        border: 1px solid #555;
        padding: 10px;
        font-family: monospace;
        margin-bottom: 10px;
        box-sizing: border-box;
      }
      .sidebar-card {
        background: #1a1a1a;
        border: 1px solid #444;
        padding: 10px;
        margin-bottom: 10px;
      }
      .ship-card {
        background: #1a1a1a;
        border: 1px solid #444;
        padding: 8px;
        margin-bottom: 8px;
      }
      .ship-card h4 {
        margin: 0 0 5px 0;
        color: #fff;
        font-size: 1em;
      }
      .ship-card textarea {
        height: 40px;
        margin-bottom: 5px;
      }
      #systemOutput {
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Top bar for nav and controls -->
    <div id="topBar">
      <div id="navContainer"></div>
      <div class="controls">
        <button id="resetViewBtn">Reset View</button>
        <button id="saveMapBtn">Save Map</button>
        <input type="file" id="loadMapInput" accept=".json" />
        <input type="text" id="nodeSearch" placeholder="Search Node" />
        <input type="text" id="shipSearch" placeholder="Search Ship" />
        <button id="zoomInBtn">Zoom In</button>
        <button id="zoomOutBtn">Zoom Out</button>
      </div>
    </div>

    <!-- Main flex container: canvas left, sidebar right -->
    <div id="mainContainer">
      <div id="canvasContainer">
        <canvas id="galaxyCanvas"></canvas>
      </div>
      <div id="sidebar">
        <div class="sidebar-card">
          <h2>System Details</h2>
          <textarea id="systemDetails" rows="5"></textarea>
          <button id="regenerateBtn">Regenerate</button>
          <button id="addShipBtn">Add Ship</button>
        </div>
        <h3>Ships</h3>
        <div id="shipContainer"></div>
      </div>
    </div>

    <!-- Hidden output for systemgen.js rendering -->
    <div id="systemOutput"></div>

    <!-- 1) Load nav.html via fetch -->
    <script>
      fetch('nav.html')
        .then(response => response.text())
        .then(data => {
          document.getElementById('navContainer').innerHTML = data;
        })
        .catch(err => console.error('Error loading nav:', err));
    </script>

    <!-- 2) Load your systemgen.js (defines generateSystem, etc.) -->
    <script src="systemgen.js"></script>

    <!-- 3) Main Galaxy Code -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded. Starting galaxy generator...");

      const canvas = document.getElementById("galaxyCanvas");
      const ctx = canvas.getContext("2d");

      // Keep an internal "actual" pixel width/height for the canvas
      function resizeCanvas() {
        // match the container's size
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }
      // Recompute size on window resize or layout changes
      new ResizeObserver(resizeCanvas).observe(document.getElementById("canvasContainer"));
      resizeCanvas();

      // Make sure textareas don't bubble wheel events to the canvas
      document.querySelectorAll('textarea').forEach(ta => {
        ta.addEventListener('wheel', e => e.stopPropagation());
      });

      // ARROW KEY SUPPORT
      // Pan the map with arrow keys (unless typing in an input/textarea)
      document.addEventListener('keydown', e => {
        // If focus is in a text field, ignore
        if (['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;

        const panStep = 20;
        switch(e.key) {
          case 'ArrowUp':
            offsetY += panStep;
            e.preventDefault();
            render();
            break;
          case 'ArrowDown':
            offsetY -= panStep;
            e.preventDefault();
            render();
            break;
          case 'ArrowLeft':
            offsetX += panStep;
            e.preventDefault();
            render();
            break;
          case 'ArrowRight':
            offsetX -= panStep;
            e.preventDefault();
            render();
            break;
          default:
            break;
        }
      });

      // Basic panning & zoom
      let offsetX = 0, offsetY = 0, scale = 1;
      let isPanning = false;
      let startPan = { x: 0, y: 0 };

      // Data arrays
      let nodes = [];
      let connections = [];
      let clusters = [];
      let selectedNode = null;
      let hoverNode = null;

      // Galaxy parameters (tweak as needed)
      const worldWidth = 3000;
      const worldHeight = 3000;
      const minSystemDist = 40;
      const clusterCountRange = [4, 6];
      const clusterRadiusRange = [50, 100];
      const totalNodes = 500;
      const maxNodesPerCluster = 15;
      const connectorSystemsCount = 3; // bridging systems
      // Etc. from your existing code

      // Helper: distance
      function dist(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx*dx + dy*dy);
      }

      // Convert screen coords → world coords
      function screenToWorld(sx, sy) {
        const rect = canvas.getBoundingClientRect();
        const mx = sx - rect.left;  // local offset in canvas
        const my = sy - rect.top;
        const wx = (mx - offsetX) / scale;
        const wy = (my - offsetY) / scale;
        return { x: wx, y: wy };
      }

      // Convert world coords → screen coords
      function worldToScreen(wx, wy) {
        const sx = (wx * scale) + offsetX;
        const sy = (wy * scale) + offsetY;
        return { x: sx, y: sy };
      }

      // Similar system generation logic (omitted here for brevity)
      // ...
      // (Use the same code from your existing version for generateClusters, generateNodes, generateConnections, etc.)

      // For brevity, I'm pasting the final relevant logic from your existing code:
      // (With minor layout tweaks so it fits this new layout.)
      function generateClusters() { /* ... same as your code ... */ }
      function generateNodes() { /* ... same as your code ... */ }
      function generateConnections() { /* ... same as your code ... */ }
      function addConnection(nA, nB, type) { /* ... same ... */ }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw connections
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        connections.forEach(conn => {
          ctx.beginPath();
          ctx.moveTo(conn.source.x, conn.source.y);
          ctx.lineTo(conn.target.x, conn.target.y);
          if (conn.type === "A") ctx.strokeStyle = "green";
          else if (conn.type === "B") ctx.strokeStyle = "blue";
          else ctx.strokeStyle = "red";
          ctx.lineWidth = 1.5;
          ctx.stroke();
        });

        // Draw nodes
        nodes.forEach(node => {
          let r = (hoverNode === node) ? 7 : 5;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, Math.PI*2);
          ctx.fillStyle = (hoverNode === node) ? "#ff0" : "#fff";
          ctx.fill();

          // Ships
          node.ships.forEach(ship => {
            const ox = node.x + Math.cos(ship.angle)*ship.orbitRadius;
            const oy = node.y + Math.sin(ship.angle)*ship.orbitRadius;
            ctx.beginPath();
            ctx.arc(ox,oy,4,0,Math.PI*2);
            ctx.fillStyle = "yellow";
            ctx.fill();
          });
        });

        ctx.restore();

        // Labels in screen space
        nodes.forEach(node => {
          const sc = worldToScreen(node.x,node.y);
          let labelX = sc.x + 8;
          let labelY = sc.y - 8;
          ctx.font = "10px Orbitron";
          ctx.fillStyle = (hoverNode === node) ? "#ff0" : "#ccc";
          ctx.fillText(node.systemName, labelX, labelY);

          // Ship labels
          node.ships.forEach(ship => {
            const ox = node.x + Math.cos(ship.angle)*ship.orbitRadius;
            const oy = node.y + Math.sin(ship.angle)*ship.orbitRadius;
            const sPos = worldToScreen(ox,oy);
            ctx.font = "10px Orbitron";
            ctx.fillStyle = "#fff";
            ctx.fillText(ship.name, sPos.x+5, sPos.y);
          });
        });
      }

      function animate() {
        nodes.forEach(node => {
          node.ships.forEach(ship => {
            ship.angle += 0.01;
          });
        });
        render();
        requestAnimationFrame(animate);
      }

      // Mouse events
      canvas.addEventListener("mousedown", e => {
        isPanning = true;
        startPan = { x: e.clientX - offsetX, y: e.clientY - offsetY };
      });
      canvas.addEventListener("mousemove", e => {
        if (isPanning) {
          offsetX = e.clientX - startPan.x;
          offsetY = e.clientY - startPan.y;
          render();
        } else {
          const {x:wx, y:wy} = screenToWorld(e.clientX, e.clientY);
          let found = null;
          let minD = 12;
          for (let node of nodes) {
            if (dist(wx,wy,node.x,node.y) < minD) {
              found = node;
              break;
            }
          }
          if (found !== hoverNode) {
            hoverNode = found;
            render();
          }
        }
      });
      canvas.addEventListener("mouseup", () => { isPanning = false; });
      canvas.addEventListener("mouseleave", () => { isPanning = false; });

      // Mouse wheel zoom
      canvas.addEventListener("wheel", e => {
        e.preventDefault();
        const {x:wx, y:wy} = screenToWorld(e.clientX, e.clientY);
        const zoomFactor = 0.05;
        if (e.deltaY < 0) {
          scale *= (1 + zoomFactor);
        } else {
          scale /= (1 + zoomFactor);
        }
        const {x:sx, y:sy} = worldToScreen(wx,wy);
        offsetX += (e.clientX - sx);
        offsetY += (e.clientY - sy);
        render();
      });

      // Node click => sidebar
      const systemDetailsTextarea = document.getElementById("systemDetails");
      const regenerateBtn = document.getElementById("regenerateBtn");
      const addShipBtn = document.getElementById("addShipBtn");
      const shipContainer = document.getElementById("shipContainer");

      canvas.addEventListener("click", e => {
        if (isPanning) return;
        const {x:wx, y:wy} = screenToWorld(e.clientX, e.clientY);
        for (let node of nodes) {
          if (dist(wx,wy,node.x,node.y) < 8) {
            openSidebar(node);
            return;
          }
        }
      });

      function openSidebar(node) {
        selectedNode = node;
        systemDetailsTextarea.value = node.systemDetails;
        renderShipList(node);
      }

      systemDetailsTextarea.addEventListener("input", e => {
        if (selectedNode) {
          selectedNode.systemDetails = e.target.value;
        }
      });

      regenerateBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        if (typeof generateSystem === "function" && typeof generateSystemText === "function") {
          generateSystem();
          selectedNode.systemDetails = generateSystemText();
          systemDetailsTextarea.value = selectedNode.systemDetails;
        }
      });

      addShipBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        const shipName = prompt("Enter ship name:");
        if (shipName) {
          selectedNode.ships.push({
            name: shipName,
            orbitRadius: 80 + Math.random()*20,
            angle: Math.random()*Math.PI*2,
            customData: ""
          });
          renderShipList(selectedNode);
        }
      });

      function renderShipList(node) {
        let html = "";
        node.ships.forEach((ship, idx) => {
          html += `
            <div class="ship-card" id="shipCard${idx}">
              <h4>${ship.name}</h4>
              <textarea oninput="updateShipData(${idx}, this.value)">${ship.customData||""}</textarea>
              <label>Move to: </label>
              <select onchange="moveShip(${idx}, this.value)">
                <option value="">(choose system)</option>
                ${getConnectedSystems(node).map(n => `
                  <option value="${n.id}">${n.systemName}</option>
                `).join("")}
              </select>
              <button onclick="deleteShip(${idx})">Delete</button>
            </div>
          `;
        });
        shipContainer.innerHTML = html;
      }

      function getConnectedSystems(node) {
        const connected = [];
        connections.forEach(conn => {
          if (conn.source === node && conn.target !== node) {
            connected.push(conn.target);
          } else if (conn.target === node && conn.source !== node) {
            connected.push(conn.source);
          }
        });
        return connected;
      }

      // Expose some global functions so the inline HTML can call them
      window.updateShipData = function(idx, val) {
        if (!selectedNode) return;
        selectedNode.ships[idx].customData = val;
      };
      window.deleteShip = function(idx) {
        if (!selectedNode) return;
        selectedNode.ships.splice(idx,1);
        renderShipList(selectedNode);
      };
      window.moveShip = function(idx, targetId) {
        if (!selectedNode || !targetId) return;
        const ship = selectedNode.ships[idx];
        const targetNode = nodes.find(n => n.id == targetId);
        if (targetNode && targetNode !== selectedNode) {
          selectedNode.ships.splice(idx,1);
          targetNode.ships.push(ship);
          renderShipList(selectedNode);
        }
      };

      // Searching
      document.getElementById("nodeSearch").addEventListener("change", e => {
        const query = e.target.value.toLowerCase();
        const found = nodes.find(n => n.systemName.toLowerCase().includes(query));
        if (found) {
          offsetX = canvas.width/2 - found.x*scale;
          offsetY = canvas.height/2 - found.y*scale;
          render();
        }
      });
      document.getElementById("shipSearch").addEventListener("change", e => {
        const query = e.target.value.toLowerCase();
        for (let node of nodes) {
          const ship = node.ships.find(s => s.name.toLowerCase().includes(query));
          if (ship) {
            offsetX = canvas.width/2 - node.x*scale;
            offsetY = canvas.height/2 - node.y*scale;
            render();
            break;
          }
        }
      });

      // Zoom & Reset
      document.getElementById("zoomInBtn").addEventListener("click", () => {
        const cx = canvas.width/2;
        const cy = canvas.height/2;
        const {x:wx, y:wy} = screenToWorld(cx, cy);
        scale *= 1.05;
        const {x:sx, y:sy} = worldToScreen(wx,wy);
        offsetX += (cx - sx);
        offsetY += (cy - sy);
        render();
      });
      document.getElementById("zoomOutBtn").addEventListener("click", () => {
        const cx = canvas.width/2;
        const cy = canvas.height/2;
        const {x:wx, y:wy} = screenToWorld(cx, cy);
        scale /= 1.05;
        const {x:sx, y:sy} = worldToScreen(wx,wy);
        offsetX += (cx - sx);
        offsetY += (cy - sy);
        render();
      });
      document.getElementById("resetViewBtn").addEventListener("click", () => {
        offsetX = 0;
        offsetY = 0;
        scale = 1;
        render();
      });

      // Save & Load
      document.getElementById("saveMapBtn").addEventListener("click", () => {
        const mapData = {
          nodes,
          connections,
          offsetX,
          offsetY,
          scale,
          clusters
        };
        const dataStr = "data:text/json;charset=utf-8," +
          encodeURIComponent(JSON.stringify(mapData, null, 2));
        const dlAnchor = document.createElement("a");
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "galaxy_map.json");
        document.body.appendChild(dlAnchor);
        dlAnchor.click();
        dlAnchor.remove();
      });
      document.getElementById("loadMapInput").addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const loaded = JSON.parse(evt.target.result);
          nodes = loaded.nodes || [];
          connections = loaded.connections || [];
          offsetX = loaded.offsetX || 0;
          offsetY = loaded.offsetY || 0;
          scale = loaded.scale || 1;
          clusters = loaded.clusters || [];
          console.log("Loaded map. Node count:", nodes.length, 
                      "Connection count:", connections.length);
          render();
        };
        reader.readAsText(file);
      });

      // Generate + Animate
      generateNodes();
      generateConnections();
      render();
      animate();
    });
    </script>
  </body>
</html>
