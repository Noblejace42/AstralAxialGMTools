<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Galaxy Generator</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Additional styles for the galaxy generator */
      #galaxyCanvas {
        border: 1px solid #444;
        background: #000;
        display: block;
        margin: 20px auto;
      }
      /* Sidebar for node (system) details */
      #sidebar {
        position: fixed;
        right: -400px;
        top: 0;
        width: 400px;
        height: 100%;
        background: #262626;
        color: #ccc;
        overflow-y: auto;
        transition: right 0.3s ease;
        padding: 20px;
        z-index: 1500;
      }
      #sidebar.open {
        right: 0;
      }
      #sidebar textarea {
        width: 100%;
        height: 300px;
        background: #1a1a1a;
        color: #ddd;
        border: 1px solid #555;
        padding: 10px;
        font-family: monospace;
        margin-bottom: 10px;
      }
      /* Controls styling */
      .controls {
        text-align: center;
        margin: 10px;
      }
      .controls input[type="text"] {
        margin: 0 5px;
        padding: 5px;
      }
    </style>
  </head>
  <body>
    <nav>
      <div class="nav-left">
        <a href="systemgen.html">System Generator</a> |
        <a href="lifepath.html">Lifepath Generator</a> |
        <a href="weapongenerator.html">Weapon Generator</a> |
        <a href="combat_tracker.html">Combat Tracker</a> |
        <a href="abilitytree.html">Abilities</a> |
        <a href="shiphardpointgenerator.html">Shipyard</a> |
        <a href="galaxygen.html">Galaxy Generator</a>
      </div>
      <div class="nav-right">
        <a href="index.html" class="distinct-button">Home</a>
      </div>
    </nav>

    <div class="controls">
      <button id="resetViewBtn">Reset View</button>
      <button id="saveMapBtn">Save Map</button>
      <input type="file" id="loadMapInput" accept=".json">
      <input type="text" id="nodeSearch" placeholder="Search Node">
      <input type="text" id="shipSearch" placeholder="Search Ship">
      <button id="zoomInBtn">Zoom In</button>
      <button id="zoomOutBtn">Zoom Out</button>
    </div>

    <canvas id="galaxyCanvas" width="800" height="600"></canvas>

    <!-- Sidebar for System Details -->
    <div id="sidebar">
      <h2>System Details</h2>
      <textarea id="systemDetails"></textarea>
      <br />
      <button id="regenerateBtn">Regenerate</button>
      <button id="closeSidebarBtn">Close</button>
      <button id="addShipBtn">Add Ship</button>
    </div>

    <script src="systemgen.js"></script>
    <script>
      /* --- Global Setup and Variables --- */
      const canvas = document.getElementById("galaxyCanvas");
      const ctx = canvas.getContext("2d");

      // Panning and zooming variables
      let offsetX = 0,
        offsetY = 0,
        scale = 1;
      let isPanning = false;
      let startPan = { x: 0, y: 0 };

      // Data arrays for nodes, connections and clusters
      let nodes = [];
      let connections = [];
      let clusters = [];
      let selectedNode = null;

      // Define world dimensions (for panning beyond canvas size)
      const worldWidth = 5000;
      const worldHeight = 5000;

      /* --- Cluster & Node Generation --- */
      function generateClusters() {
        clusters = [];
        // Dynamically choose between 5 and 10 clusters
        const clusterCount = Math.floor(Math.random() * 6) + 5;
        for (let i = 0; i < clusterCount; i++) {
          const center = {
            x: Math.random() * worldWidth,
            y: Math.random() * worldHeight,
          };
          // Random radius for cluster spread
          const radius = Math.random() * 200 + 100; // 100 to 300
          clusters.push({ center, radius, nodes: [] });
        }
      }

      function generateNodes() {
        nodes = [];
        generateClusters();
        const totalNodes = 500;
        // Evenly divide nodes among clusters (with a bit of randomness)
        let nodesPerCluster = Math.floor(totalNodes / clusters.length);
        let extraNodes = totalNodes % clusters.length;
        clusters.forEach((cluster) => {
          let count = nodesPerCluster;
          if (extraNodes > 0) {
            count++;
            extraNodes--;
          }
          for (let i = 0; i < count; i++) {
            // Place node randomly within cluster's radius (using polar coordinates)
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * cluster.radius;
            const x = cluster.center.x + Math.cos(angle) * distance;
            const y = cluster.center.y + Math.sin(angle) * distance;
            // Generate a system name via systemgen.js; fallback if function not found
            let systemName =
              typeof generateSystemName === "function"
                ? generateSystemName()
                : "System " + (nodes.length + 1);
            // Generate system details using systemgen.js functions
            if (
              typeof generateSystem === "function" &&
              typeof generateSystemText === "function"
            ) {
              generateSystem();
              var systemText = generateSystemText();
            } else {
              var systemText = "System details not available.";
            }
            const node = {
              id: nodes.length,
              x,
              y,
              cluster: cluster,
              systemName,
              systemDetails: systemText,
              ships: [], // Array for ship objects
            };
            nodes.push(node);
            cluster.nodes.push(node);
          }
        });
      }

      /* --- Connection Generation --- */
      function generateConnections() {
        connections = [];
        // Type A: Connect nodes within the same cluster
        clusters.forEach((cluster) => {
          const clusterNodes = cluster.nodes;
          for (let i = 0; i < clusterNodes.length; i++) {
            for (let j = i + 1; j < clusterNodes.length; j++) {
              // Random chance to connect within cluster
              if (Math.random() < 0.05) {
                connections.push({
                  source: clusterNodes[i],
                  target: clusterNodes[j],
                  type: "A",
                });
              }
            }
          }
        });
        // Inter-cluster connections
        for (let i = 0; i < clusters.length; i++) {
          for (let j = i + 1; j < clusters.length; j++) {
            const clusterA = clusters[i];
            const clusterB = clusters[j];
            const dx = clusterA.center.x - clusterB.center.x;
            const dy = clusterA.center.y - clusterB.center.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            // Decide connection type based on distance (B for close, C for far)
            let connectionType = "B";
            if (dist > worldWidth / 3) {
              connectionType = "C";
            }
            // Create 1-3 random connections between clusters
            const connectionsCount = Math.floor(Math.random() * 3) + 1;
            for (let k = 0; k < connectionsCount; k++) {
              const nodeA =
                clusterA.nodes[
                  Math.floor(Math.random() * clusterA.nodes.length)
                ];
              const nodeB =
                clusterB.nodes[
                  Math.floor(Math.random() * clusterB.nodes.length)
                ];
              connections.push({
                source: nodeA,
                target: nodeB,
                type: connectionType,
              });
            }
          }
        }
      }

      /* --- Rendering the Map --- */
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Draw connections
        connections.forEach((conn) => {
          ctx.beginPath();
          ctx.moveTo(conn.source.x, conn.source.y);
          ctx.lineTo(conn.target.x, conn.target.y);
          if (conn.type === "A") {
            ctx.strokeStyle = "green";
          } else if (conn.type === "B") {
            ctx.strokeStyle = "blue";
          } else if (conn.type === "C") {
            ctx.strokeStyle = "red";
          }
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        // Draw nodes and their system names
        nodes.forEach((node) => {
          ctx.beginPath();
          ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.font = "12px Orbitron";
          ctx.fillStyle = "#ccc";
          ctx.fillText(node.systemName, node.x + 8, node.y - 8);

          // Draw ships orbiting the node (if any)
          if (node.ships) {
            node.ships.forEach((ship) => {
              const orbitX = node.x + Math.cos(ship.angle) * ship.orbitRadius;
              const orbitY = node.y + Math.sin(ship.angle) * ship.orbitRadius;
              ctx.beginPath();
              ctx.arc(orbitX, orbitY, 3, 0, Math.PI * 2);
              ctx.fillStyle = "yellow";
              ctx.fill();
              ctx.font = "10px Orbitron";
              ctx.fillStyle = "#fff";
              ctx.fillText(ship.name, orbitX + 5, orbitY);
            });
          }
        });

        ctx.restore();
      }

      /* --- Animation Loop for Ship Orbiting --- */
      function animate() {
        nodes.forEach((node) => {
          if (node.ships) {
            node.ships.forEach((ship) => {
              ship.angle += 0.01; // Smooth orbiting speed
            });
          }
        });
        render();
        requestAnimationFrame(animate);
      }

      /* --- Panning and Zooming Event Handlers --- */
      canvas.addEventListener("mousedown", (e) => {
        isPanning = true;
        startPan = { x: e.clientX - offsetX, y: e.clientY - offsetY };
      });
      canvas.addEventListener("mousemove", (e) => {
        if (isPanning) {
          offsetX = e.clientX - startPan.x;
          offsetY = e.clientY - startPan.y;
          render();
        }
      });
      canvas.addEventListener("mouseup", () => {
        isPanning = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isPanning = false;
      });
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const zoomFactor = 1.1;
        if (e.deltaY < 0) {
          scale *= zoomFactor;
        } else {
          scale /= zoomFactor;
        }
        render();
      });

      /* --- Node Selection and Sidebar Modal --- */
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;
        // Check if a node was clicked (using an 8px threshold)
        for (let node of nodes) {
          const dx = node.x - x;
          const dy = node.y - y;
          if (Math.sqrt(dx * dx + dy * dy) < 8) {
            selectedNode = node;
            openSidebar(node);
            return;
          }
        }
      });

      const sidebar = document.getElementById("sidebar");
      const systemDetailsTextarea = document.getElementById("systemDetails");
      const regenerateBtn = document.getElementById("regenerateBtn");
      const closeSidebarBtn = document.getElementById("closeSidebarBtn");
      const addShipBtn = document.getElementById("addShipBtn");

      function openSidebar(node) {
        systemDetailsTextarea.value = node.systemDetails;
        sidebar.classList.add("open");
      }
      regenerateBtn.addEventListener("click", () => {
        if (selectedNode) {
          if (
            typeof generateSystem === "function" &&
            typeof generateSystemText === "function"
          ) {
            generateSystem();
            selectedNode.systemDetails = generateSystemText();
            systemDetailsTextarea.value = selectedNode.systemDetails;
          }
        }
      });
      closeSidebarBtn.addEventListener("click", () => {
        sidebar.classList.remove("open");
      });
      addShipBtn.addEventListener("click", () => {
        if (selectedNode) {
          const shipName = prompt("Enter ship name:");
          if (shipName) {
            const newShip = {
              name: shipName,
              orbitRadius: 20 + Math.random() * 10, // random between 20-30
              angle: Math.random() * Math.PI * 2,
            };
            selectedNode.ships.push(newShip);
          }
        }
      });

      /* --- Search Functionality --- */
      document.getElementById("nodeSearch").addEventListener("change", (e) => {
        const query = e.target.value.toLowerCase();
        const found = nodes.find((node) =>
          node.systemName.toLowerCase().includes(query)
        );
        if (found) {
          offsetX = canvas.width / 2 - found.x * scale;
          offsetY = canvas.height / 2 - found.y * scale;
          render();
        }
      });
      document.getElementById("shipSearch").addEventListener("change", (e) => {
        const query = e.target.value.toLowerCase();
        for (let node of nodes) {
          const ship = node.ships.find((ship) =>
            ship.name.toLowerCase().includes(query)
          );
          if (ship) {
            offsetX = canvas.width / 2 - node.x * scale;
            offsetY = canvas.height / 2 - node.y * scale;
            render();
            break;
          }
        }
      });

      /* --- Zoom and Reset Controls --- */
      document
        .getElementById("zoomInBtn")
        .addEventListener("click", () => {
          scale *= 1.1;
          render();
        });
      document
        .getElementById("zoomOutBtn")
        .addEventListener("click", () => {
          scale /= 1.1;
          render();
        });
      document
        .getElementById("resetViewBtn")
        .addEventListener("click", () => {
          offsetX = 0;
          offsetY = 0;
          scale = 1;
          render();
        });

      /* --- Save and Load Map --- */
      document.getElementById("saveMapBtn").addEventListener("click", () => {
        const mapData = {
          nodes,
          connections,
          offsetX,
          offsetY,
          scale,
          clusters,
        };
        const dataStr =
          "data:text/json;charset=utf-8," +
          encodeURIComponent(JSON.stringify(mapData));
        const dlAnchorElem = document.createElement("a");
        dlAnchorElem.setAttribute("href", dataStr);
        dlAnchorElem.setAttribute("download", "galaxy_map.json");
        dlAnchorElem.click();
      });
      document
        .getElementById("loadMapInput")
        .addEventListener("change", (e) => {
          const file = e.target.files[0];
          const reader = new FileReader();
          reader.onload = function (event) {
            const loadedData = JSON.parse(event.target.result);
            nodes = loadedData.nodes;
            connections = loadedData.connections;
            offsetX = loadedData.offsetX;
            offsetY = loadedData.offsetY;
            scale = loadedData.scale;
            clusters = loadedData.clusters;
            render();
          };
          reader.readAsText(file);
        });

      /* --- Initial Generation and Animation --- */
      generateNodes();
      generateConnections();
      render();
      animate();
    </script>
  </body>
</html>
