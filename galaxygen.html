<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Astral Axial Galaxy Generator</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Remove or override any starry background from styles.css */
      body {
        margin: 0;
        padding: 0;
        background: #000 !important; /* Solid black background */
        padding-top: 60px; /* If you have a fixed nav at ~60px high */
        color: #ccc;
        font-family: 'Orbitron', sans-serif;
      }
      #navContainer {
        position: relative;
        z-index: 1000;
      }
      .controls {
        text-align: center;
        margin-top: 10px;
      }
      /* Canvas should fill the remaining space */
      #galaxyCanvas {
        position: absolute;
        top: 60px;
        left: 0;
        width: calc(100% - 0px);
        height: calc(100% - 60px);
        background: #000; /* So it's clearly visible */
        cursor: grab;
      }
      #galaxyCanvas:active {
        cursor: grabbing;
      }
      /* Sidebar for system details */
      #sidebar {
        position: absolute;
        top: 60px;
        right: -400px;
        width: 400px;
        height: calc(100% - 60px);
        background: #262626;
        color: #ccc;
        overflow-y: auto;
        transition: right 0.3s ease;
        padding: 20px;
        z-index: 2000;
      }
      #sidebar.open {
        right: 0;
      }
      /* A little card for the top buttons in the sidebar */
      .sidebar-card {
        background: #1a1a1a;
        border: 1px solid #444;
        padding: 10px;
        margin-bottom: 10px;
      }
      #sidebar textarea {
        width: 100%;
        background: #1a1a1a;
        color: #ddd;
        border: 1px solid #555;
        padding: 10px;
        font-family: monospace;
        margin-bottom: 10px;
      }
      /* Hidden div so systemgen.js can render text if needed */
      #systemOutput {
        display: none;
      }
      /* Ship cards styling */
      .ship-card {
        background: #1a1a1a;
        border: 1px solid #444;
        padding: 8px;
        margin-bottom: 8px;
      }
      .ship-card h4 {
        margin: 0 0 5px 0;
        color: #fff;
        font-size: 1em;
      }
      .ship-card textarea {
        width: 100%;
        height: 40px;
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <!-- Container for nav.html -->
    <div id="navContainer"></div>

    <div class="controls">
      <button id="resetViewBtn">Reset View</button>
      <button id="saveMapBtn">Save Map</button>
      <input type="file" id="loadMapInput" accept=".json" />
      <input type="text" id="nodeSearch" placeholder="Search Node" />
      <input type="text" id="shipSearch" placeholder="Search Ship" />
      <button id="zoomInBtn">Zoom In</button>
      <button id="zoomOutBtn">Zoom Out</button>
    </div>

    <canvas id="galaxyCanvas"></canvas>

    <div id="sidebar">
      <div class="sidebar-card">
        <h2>System Details</h2>
        <textarea id="systemDetails" rows="6"></textarea>
        <button id="regenerateBtn">Regenerate</button>
        <button id="closeSidebarBtn">Close</button>
        <button id="addShipBtn">Add Ship</button>
      </div>
      <h3>Ships</h3>
      <div id="shipContainer"></div>
    </div>

    <div id="systemOutput"></div>

    <!-- 1) Load nav via fetch -->
    <script>
      fetch('nav.html')
        .then(response => response.text())
        .then(data => {
          document.getElementById('navContainer').innerHTML = data;
        })
        .catch(err => console.error('Error loading nav:', err));
    </script>

    <!-- 2) Load systemgen.js -->
    <script src="systemgen.js"></script>

    <!-- 3) Main Galaxy Code -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded. Starting galaxy generator...");

      // Adjust canvas size
      const canvas = document.getElementById("galaxyCanvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 60; // subtract nav height
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Basic panning & zoom
      let offsetX = 0, offsetY = 0, scale = 1;
      let isPanning = false;
      let startPan = { x: 0, y: 0 };

      // Galaxy data
      let nodes = [];
      let connections = [];
      let clusters = [];
      let selectedNode = null;
      let hoverNode = null;

      // Make the galaxy smaller & cap cluster node count
      const worldWidth = 3000;
      const worldHeight = 3000;
      const maxNodesPerCluster = 15; // cap

      // ---- Helper functions ----
      function dist(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx*dx + dy*dy);
      }
      // Check line intersection to skip overlapping lines
      function linesIntersect(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2) {
        // Based on standard segment intersection
        const d = (by2 - by1)*(ax2 - ax1) - (bx2 - bx1)*(ay2 - ay1);
        if (d === 0) return false; // parallel
        const ua = ((bx2 - bx1)*(ay1 - by1) - (by2 - by1)*(ax1 - bx1)) / d;
        const ub = ((ax2 - ax1)*(ay1 - by1) - (ay2 - ay1)*(ax1 - bx1)) / d;
        return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);
      }

      // ---- Cluster & Node Generation ----
      function generateClusters() {
        clusters = [];
        const clusterCount = Math.floor(Math.random() * 3) + 4; // 4-6
        for (let i = 0; i < clusterCount; i++) {
          const center = {
            x: Math.random() * worldWidth,
            y: Math.random() * worldHeight
          };
          const radius = Math.random() * 100 + 50; // 50-150
          clusters.push({ center, radius, nodes: [] });
        }
      }

      function generateNodes() {
        nodes = [];
        generateClusters();
        const totalNodes = 500;
        let nodesPerCluster = Math.floor(totalNodes / clusters.length);
        let extraNodes = totalNodes % clusters.length;

        clusters.forEach(cluster => {
          let count = nodesPerCluster;
          if (extraNodes > 0) {
            count++;
            extraNodes--;
          }
          // Cap each cluster at 15
          count = Math.min(count, maxNodesPerCluster);

          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * cluster.radius;
            const x = cluster.center.x + Math.cos(angle) * distance;
            const y = cluster.center.y + Math.sin(angle) * distance;

            // Use systemgen's 6-digit code if available
            let systemName = "Sys" + (nodes.length + 1);
            if (typeof generateSystemCode === "function") {
              systemName = generateSystemCode(); 
            }

            let systemText = "System details not available.";
            if (typeof generateSystem === "function" &&
                typeof generateSystemText === "function") {
              generateSystem();
              systemText = generateSystemText();
            }

            const node = {
              id: nodes.length,
              x,
              y,
              cluster,
              systemName,
              systemDetails: systemText,
              ships: []
            };
            nodes.push(node);
            cluster.nodes.push(node);
          }
        });
        console.log("Generated", nodes.length, "nodes in", clusters.length, "clusters.");
      }

      // ---- Connection Generation (no overlaps) ----
      function generateConnections() {
        connections = [];

        // 1) Connect within same cluster
        clusters.forEach(cluster => {
          const cNodes = cluster.nodes;
          for (let i = 0; i < cNodes.length; i++) {
            for (let j = i+1; j < cNodes.length; j++) {
              if (Math.random() < 0.05) {
                addConnection(cNodes[i], cNodes[j], "A");
              }
            }
          }
        });

        // 2) Inter-cluster
        for (let i = 0; i < clusters.length; i++) {
          for (let j = i+1; j < clusters.length; j++) {
            const cA = clusters[i];
            const cB = clusters[j];
            const dx = cA.center.x - cB.center.x;
            const dy = cA.center.y - cB.center.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            let connType = (d > worldWidth/3) ? "C" : "B";
            const connCount = Math.floor(Math.random()*3)+1;
            let attempts = 0;

            for (let k = 0; k < connCount; k++) {
              // We'll attempt up to 10 times to avoid overlap
              let success = false;
              while (!success && attempts < 10) {
                attempts++;
                const nodeA = cA.nodes[Math.floor(Math.random() * cA.nodes.length)];
                const nodeB = cB.nodes[Math.floor(Math.random() * cB.nodes.length)];
                success = addConnection(nodeA, nodeB, connType);
              }
            }
          }
        }
        console.log("Generated", connections.length, "connections.");
      }

      // Helper to add a connection if it doesn't intersect existing lines
      function addConnection(nA, nB, cType) {
        // Check intersection with existing
        for (let c of connections) {
          if (linesIntersect(
            nA.x, nA.y, nB.x, nB.y,
            c.source.x, c.source.y, c.target.x, c.target.y
          )) {
            return false; // skip
          }
        }
        // If no intersection, add it
        connections.push({
          source: nA,
          target: nB,
          type: cType
        });
        return true;
      }

      // ---- Rendering ----
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Draw connections
        connections.forEach(conn => {
          ctx.beginPath();
          ctx.moveTo(conn.source.x, conn.source.y);
          ctx.lineTo(conn.target.x, conn.target.y);
          if (conn.type === "A") ctx.strokeStyle = "green";
          else if (conn.type === "B") ctx.strokeStyle = "blue";
          else ctx.strokeStyle = "red"; // C
          ctx.lineWidth = 1.5; // thinner lines for readability
          ctx.stroke();
        });

        // Draw nodes & ships
        nodes.forEach(node => {
          // If hovered
          let radius = (hoverNode === node) ? 7 : 5;
          ctx.beginPath();
          ctx.arc(node.x, node.y, radius, 0, Math.PI*2);
          ctx.fillStyle = (hoverNode === node) ? "#ff0" : "#fff";
          ctx.fill();

          // Draw node label
          ctx.font = "12px Orbitron";
          ctx.fillStyle = "#ccc";
          ctx.fillText(node.systemName, node.x + 8, node.y - 8);

          // Draw ships orbiting
          node.ships.forEach(ship => {
            const orbitX = node.x + Math.cos(ship.angle)*ship.orbitRadius;
            const orbitY = node.y + Math.sin(ship.angle)*ship.orbitRadius;
            ctx.beginPath();
            ctx.arc(orbitX, orbitY, 4, 0, Math.PI*2);
            ctx.fillStyle = "yellow";
            ctx.fill();
            // Label the ship
            ctx.font = "10px Orbitron";
            ctx.fillStyle = "#fff";
            ctx.fillText(ship.name, orbitX+5, orbitY);
          });
        });

        ctx.restore();
      }

      // Animate ship orbits
      function animate() {
        nodes.forEach(node => {
          node.ships.forEach(ship => {
            ship.angle += 0.01; 
          });
        });
        render();
        requestAnimationFrame(animate);
      }

      // ---- Mouse & Zoom ----
      canvas.addEventListener("mousedown", e => {
        isPanning = true;
        startPan = { x: e.clientX - offsetX, y: e.clientY - offsetY };
      });
      canvas.addEventListener("mousemove", e => {
        if (isPanning) {
          offsetX = e.clientX - startPan.x;
          offsetY = e.clientY - startPan.y;
          render();
        } else {
          // Hover detection
          const rect = canvas.getBoundingClientRect();
          const mx = (e.clientX - rect.left - offsetX) / scale;
          const my = (e.clientY - rect.top - offsetY) / scale;
          let foundNode = null;
          let minDist = 12;
          for (let node of nodes) {
            if (dist(mx,my,node.x,node.y) < minDist) {
              foundNode = node;
              break;
            }
          }
          if (foundNode !== hoverNode) {
            hoverNode = foundNode;
            render();
          }
        }
      });
      canvas.addEventListener("mouseup", () => { isPanning = false; });
      canvas.addEventListener("mouseleave", () => { isPanning = false; });

      // Mousewheel zoom centered on cursor
      canvas.addEventListener("wheel", e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offsetX) / scale;
        const mouseY = (e.clientY - rect.top - offsetY) / scale;
        const zoomFactor = 0.05;
        if (e.deltaY < 0) {
          // zoom in
          scale *= (1 + zoomFactor);
        } else {
          // zoom out
          scale /= (1 + zoomFactor);
        }
        // Adjust offsets so mouse stays in place
        offsetX = e.clientX - (mouseX * scale);
        offsetY = e.clientY - (mouseY * scale);
        render();
      });

      // ---- Sidebar & Node Click ----
      const sidebar = document.getElementById("sidebar");
      const systemDetailsTextarea = document.getElementById("systemDetails");
      const regenerateBtn = document.getElementById("regenerateBtn");
      const closeSidebarBtn = document.getElementById("closeSidebarBtn");
      const addShipBtn = document.getElementById("addShipBtn");
      const shipContainer = document.getElementById("shipContainer");

      function openSidebar(node) {
        selectedNode = node;
        systemDetailsTextarea.value = node.systemDetails;
        sidebar.classList.add("open");
        renderShipList(node);
      }

      canvas.addEventListener("click", e => {
        if (isPanning) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;
        for (let node of nodes) {
          if (dist(x,y,node.x,node.y) < 8) {
            openSidebar(node);
            return;
          }
        }
      });

      regenerateBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        if (typeof generateSystem === "function" &&
            typeof generateSystemText === "function") {
          generateSystem();
          selectedNode.systemDetails = generateSystemText();
          systemDetailsTextarea.value = selectedNode.systemDetails;
        }
      });

      closeSidebarBtn.addEventListener("click", () => {
        sidebar.classList.remove("open");
      });

      // Update node's systemDetails whenever the user types
      systemDetailsTextarea.addEventListener("input", () => {
        if (selectedNode) {
          selectedNode.systemDetails = systemDetailsTextarea.value;
        }
      });

      // Add Ship
      addShipBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        const shipName = prompt("Enter ship name:");
        if (shipName) {
          selectedNode.ships.push({
            name: shipName,
            orbitRadius: 60 + Math.random()*20, // bigger radius so it's visible
            angle: Math.random()*Math.PI*2,
            customData: ""
          });
          renderShipList(selectedNode);
        }
      });

      // Render the ships in the sidebar
      function renderShipList(node) {
        let html = "";
        node.ships.forEach((ship, idx) => {
          html += `
            <div class="ship-card" id="shipCard${idx}">
              <h4>${ship.name}</h4>
              <textarea oninput="updateShipData(${idx}, this.value)">${ship.customData||""}</textarea>
              <label>Move to: </label>
              <select onchange="moveShip(${idx}, this.value)">
                <option value="">(choose system)</option>
                ${getConnectedSystems(node).map(n => `
                  <option value="${n.id}">${n.systemName}</option>
                `).join("")}
              </select>
              <button onclick="deleteShip(${idx})">Delete</button>
            </div>
          `;
        });
        shipContainer.innerHTML = html;
      }

      // Return an array of nodes that are directly connected to 'node'
      function getConnectedSystems(node) {
        const connected = [];
        connections.forEach(conn => {
          if (conn.source === node && conn.target !== node) {
            connected.push(conn.target);
          } else if (conn.target === node && conn.source !== node) {
            connected.push(conn.source);
          }
        });
        return connected;
      }

      // Expose some functions so inline onclick calls work
      window.updateShipData = function(idx, val) {
        if (selectedNode) {
          selectedNode.ships[idx].customData = val;
        }
      };
      window.deleteShip = function(idx) {
        if (selectedNode) {
          selectedNode.ships.splice(idx,1);
          renderShipList(selectedNode);
        }
      };
      window.moveShip = function(idx, targetId) {
        if (!selectedNode || !targetId) return;
        const ship = selectedNode.ships[idx];
        // find the node with targetId
        const targetNode = nodes.find(n => n.id == targetId);
        if (targetNode && targetNode !== selectedNode) {
          // remove from current node, push to target
          selectedNode.ships.splice(idx,1);
          targetNode.ships.push(ship);
          renderShipList(selectedNode); 
        }
      };

      // ---- Searching ----
      document.getElementById("nodeSearch").addEventListener("change", e => {
        const query = e.target.value.toLowerCase();
        const found = nodes.find(n => n.systemName.toLowerCase().includes(query));
        if (found) {
          offsetX = canvas.width/2 - found.x * scale;
          offsetY = canvas.height/2 - found.y * scale;
          render();
        }
      });
      document.getElementById("shipSearch").addEventListener("change", e => {
        const query = e.target.value.toLowerCase();
        for (let node of nodes) {
          const ship = node.ships.find(s => s.name.toLowerCase().includes(query));
          if (ship) {
            offsetX = canvas.width/2 - node.x * scale;
            offsetY = canvas.height/2 - node.y * scale;
            render();
            break;
          }
        }
      });

      // ---- Zoom & Reset Buttons ----
      document.getElementById("zoomInBtn").addEventListener("click", () => {
        // Zoom in around center
        const cx = canvas.width/2 - offsetX;
        const cy = canvas.height/2 - offsetY;
        scale *= 1.05;
        offsetX = canvas.width/2 - cx*scale/1.05;
        offsetY = canvas.height/2 - cy*scale/1.05;
        render();
      });
      document.getElementById("zoomOutBtn").addEventListener("click", () => {
        const cx = canvas.width/2 - offsetX;
        const cy = canvas.height/2 - offsetY;
        scale /= 1.05;
        offsetX = canvas.width/2 - cx*scale*1.05;
        offsetY = canvas.height/2 - cy*scale*1.05;
        render();
      });
      document.getElementById("resetViewBtn").addEventListener("click", () => {
        offsetX = 0;
        offsetY = 0;
        scale = 1;
        render();
      });

      // ---- Save & Load ----
      document.getElementById("saveMapBtn").addEventListener("click", () => {
        const mapData = {
          nodes,
          connections,
          offsetX,
          offsetY,
          scale,
          clusters
        };
        const dataStr = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(mapData, null, 2));
        const dlAnchor = document.createElement("a");
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "galaxy_map.json");
        document.body.appendChild(dlAnchor);
        dlAnchor.click();
        dlAnchor.remove();
      });
      document.getElementById("loadMapInput").addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const loaded = JSON.parse(evt.target.result);
          nodes = loaded.nodes || [];
          connections = loaded.connections || [];
          offsetX = loaded.offsetX || 0;
          offsetY = loaded.offsetY || 0;
          scale = loaded.scale || 1;
          clusters = loaded.clusters || [];
          console.log("Loaded map. Node count:", nodes.length, 
                      "Connection count:", connections.length);
          render();
        };
        reader.readAsText(file);
      });

      // ---- Initial Gen & Animate ----
      generateNodes();
      generateConnections();
      render();
      animate();
    });
    </script>
  </body>
</html>
