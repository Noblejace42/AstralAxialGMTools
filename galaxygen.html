<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Astral Axial Galaxy Generator</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Force a black background, removing starry image */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000 !important; /* Solid black */
      }
      body {
        padding-top: 60px; /* If you have a fixed nav ~60px high */
        color: #ccc;
        font-family: 'Orbitron', sans-serif;
        overflow: hidden; /* We'll manage scrolling in the canvas & sidebar */
      }
      /* Nav container for fetched nav.html */
      #navContainer {
        position: relative;
        z-index: 1000;
      }
      .controls {
        text-align: center;
        margin-top: 10px;
      }
      /* The canvas should fill below the nav bar */
      #galaxyCanvas {
        position: absolute;
        top: 60px;
        left: 0;
        width: calc(100% - 0px);
        height: calc(100% - 60px);
        background: #000;
        cursor: grab;
      }
      #galaxyCanvas:active {
        cursor: grabbing;
      }
      /* Sidebar permanently visible on the right */
      #sidebar {
        position: absolute;
        top: 60px;
        right: 0;
        width: 400px;
        height: calc(100% - 60px);
        background: #262626;
        color: #ccc;
        overflow-y: auto;
        padding: 20px;
        z-index: 2000;
        border-left: 1px solid #444;
      }
      /* Make sure text areas don't propagate wheel events to the canvas */
      textarea {
        width: 100%;
        background: #1a1a1a;
        color: #ddd;
        border: 1px solid #555;
        padding: 10px;
        font-family: monospace;
        margin-bottom: 10px;
      }
      .sidebar-card {
        background: #1a1a1a;
        border: 1px solid #444;
        padding: 10px;
        margin-bottom: 10px;
      }
      #shipContainer .ship-card {
        background: #1a1a1a;
        border: 1px solid #444;
        padding: 8px;
        margin-bottom: 8px;
      }
      #shipContainer .ship-card h4 {
        margin: 0 0 5px 0;
        color: #fff;
        font-size: 1em;
      }
      #shipContainer .ship-card textarea {
        height: 40px;
        margin-bottom: 5px;
      }
      #systemOutput {
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Nav bar container -->
    <div id="navContainer"></div>

    <div class="controls">
      <button id="resetViewBtn">Reset View</button>
      <button id="saveMapBtn">Save Map</button>
      <input type="file" id="loadMapInput" accept=".json" />
      <input type="text" id="nodeSearch" placeholder="Search Node" />
      <input type="text" id="shipSearch" placeholder="Search Ship" />
      <button id="zoomInBtn">Zoom In</button>
      <button id="zoomOutBtn">Zoom Out</button>
    </div>

    <!-- The main drawing canvas -->
    <canvas id="galaxyCanvas"></canvas>

    <!-- Sidebar always visible -->
    <div id="sidebar">
      <div class="sidebar-card">
        <h2>System Details</h2>
        <textarea id="systemDetails" rows="5"></textarea>
        <button id="regenerateBtn">Regenerate</button>
        <button id="addShipBtn">Add Ship</button>
      </div>
      <h3>Ships</h3>
      <div id="shipContainer"></div>
    </div>

    <!-- Hidden output for systemgen.js rendering -->
    <div id="systemOutput"></div>

    <!-- 1) Load nav.html via fetch -->
    <script>
      fetch('nav.html')
        .then(response => response.text())
        .then(data => {
          document.getElementById('navContainer').innerHTML = data;
        })
        .catch(err => console.error('Error loading nav:', err));
    </script>

    <!-- 2) Load your systemgen.js (defines generateSystem, etc.) -->
    <script src="systemgen.js"></script>

    <!-- 3) Main Galaxy Code -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded. Starting galaxy generator...");

      // Canvas
      const canvas = document.getElementById("galaxyCanvas");
      const ctx = canvas.getContext("2d");

      // Resize to fill window below the nav
      function resizeCanvas() {
        canvas.width = window.innerWidth - 400; // sidebar is 400px
        canvas.height = window.innerHeight - 60; 
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Basic panning & zoom
      let offsetX = 0, offsetY = 0, scale = 1;
      let isPanning = false;
      let startPan = { x: 0, y: 0 };

      // Data
      let nodes = [];
      let connections = [];
      let clusters = [];
      let selectedNode = null;
      let hoverNode = null;

      // Galaxy parameters
      const worldWidth = 3000;
      const worldHeight = 3000;
      const minSystemDist = 40; // min distance between systems
      const clusterCountRange = [4, 6]; // 4–6 clusters
      const clusterRadiusRange = [50, 100]; // smaller radius
      const totalNodes = 500;
      const maxNodesPerCluster = 15; 
      // We'll create a few "bridge systems" for blue skip bridging
      const connectorSystemsCount = 3; // number of out-of-cluster systems

      // Make sure textareas don't bubble wheel events to the canvas
      document.querySelectorAll('textarea').forEach(ta => {
        ta.addEventListener('wheel', e => e.stopPropagation());
      });

      // ---- Helper Functions ----
      function dist(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx*dx + dy*dy);
      }

      // Transform world coords → screen coords
      function worldToScreen(wx, wy) {
        const sx = (wx * scale) + offsetX;
        const sy = (wy * scale) + offsetY;
        return { x: sx, y: sy };
      }

      // Transform screen coords → world coords
      function screenToWorld(sx, sy) {
        const wx = (sx - offsetX) / scale;
        const wy = (sy - offsetY) / scale;
        return { x: wx, y: wy };
      }

      // ---- Generate Clusters & Nodes with min distance ----
      function generateClusters() {
        clusters = [];
        const cCount = Math.floor(Math.random() * (clusterCountRange[1] - clusterCountRange[0] + 1)) 
                       + clusterCountRange[0];
        for (let i = 0; i < cCount; i++) {
          const center = {
            x: Math.random() * worldWidth,
            y: Math.random() * worldHeight
          };
          const radius = Math.random()*(clusterRadiusRange[1] - clusterRadiusRange[0]) 
                         + clusterRadiusRange[0];
          clusters.push({ center, radius, nodes: [] });
        }
      }

      function generateNodes() {
        nodes = [];
        generateClusters();

        let nodesPerCluster = Math.floor(totalNodes / clusters.length);
        let extra = totalNodes % clusters.length;

        clusters.forEach(cluster => {
          let count = nodesPerCluster;
          if (extra > 0) {
            count++;
            extra--;
          }
          // cap
          count = Math.min(count, maxNodesPerCluster);

          for (let i = 0; i < count; i++) {
            let placed = false;
            let attempts = 0;
            while(!placed && attempts < 100) {
              attempts++;
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * cluster.radius;
              let x = cluster.center.x + Math.cos(angle)*distance;
              let y = cluster.center.y + Math.sin(angle)*distance;
              // Check min distance to existing nodes in this cluster
              let tooClose = cluster.nodes.some(n => dist(n.x,n.y,x,y) < minSystemDist);
              if (!tooClose) {
                // We can place it
                let systemName = "Sys" + (nodes.length+1);
                if (typeof generateSystemCode === "function") {
                  systemName = generateSystemCode();
                }
                let systemText = "System details not available.";
                if (typeof generateSystem === "function" && 
                    typeof generateSystemText === "function") {
                  generateSystem();
                  systemText = generateSystemText();
                }
                const node = {
                  id: nodes.length,
                  x, y,
                  cluster,
                  systemName,
                  systemDetails: systemText,
                  ships: []
                };
                nodes.push(node);
                cluster.nodes.push(node);
                placed = true;
              }
            }
          }
        });

        // Add "connector systems" that float outside clusters, for bridging
        for (let i = 0; i < connectorSystemsCount; i++) {
          let x = Math.random()*worldWidth;
          let y = Math.random()*worldHeight;
          // not near cluster centers
          let systemName = "Bridge" + (i+1);
          if (typeof generateSystemCode === "function") {
            systemName = generateSystemCode();
          }
          let systemText = "Connector system bridging clusters.";
          if (typeof generateSystem === "function" && 
              typeof generateSystemText === "function") {
            generateSystem();
            systemText = generateSystemText();
          }
          const node = {
            id: nodes.length,
            x, y,
            cluster: null,
            systemName,
            systemDetails: systemText,
            ships: []
          };
          nodes.push(node);
        }

        console.log("Generated", nodes.length, "total systems across", clusters.length, "clusters + connectors.");
      }

      // ---- Connection Generation ----
      // We ensure each system in a cluster has at least one green skip.
      // We reduce green skip chance, we add more blue skip bridging,
      // and make red skip extremely rare.
      function generateConnections() {
        connections = [];

        // 1) For each cluster, ensure each node has at least 1 green skip
        // We'll do a MST-like approach or a simple chain to ensure connectivity
        clusters.forEach(cluster => {
          const cNodes = cluster.nodes;
          if (cNodes.length <= 1) return;
          // connect them in a chain
          for (let i = 0; i < cNodes.length-1; i++) {
            addConnection(cNodes[i], cNodes[i+1], "A");
          }
        });

        // Then randomly add more green connections but fewer than before
        clusters.forEach(cluster => {
          const cNodes = cluster.nodes;
          for (let i = 0; i < cNodes.length; i++) {
            for (let j = i+1; j < cNodes.length; j++) {
              // Lower chance for green skip
              if (Math.random() < 0.02) {
                addConnection(cNodes[i], cNodes[j], "A");
              }
            }
          }
        });

        // 2) Connect each cluster to each "connector system" with a blue skip
        // This ensures bridging across multiple connectors
        let connectorNodes = nodes.filter(n => n.cluster === null);
        clusters.forEach(cluster => {
          if (cluster.nodes.length === 0) return;
          const randNode = cluster.nodes[Math.floor(Math.random()*cluster.nodes.length)];
          // connect that cluster to all connector nodes with blue
          connectorNodes.forEach(connNode => {
            addConnection(randNode, connNode, "B");
          });
        });

        // 3) Possibly connect some connectors with each other using blue
        // so we can have multiple steps
        for (let i = 0; i < connectorNodes.length; i++) {
          for (let j = i+1; j < connectorNodes.length; j++) {
            if (Math.random() < 0.6) { // 60% chance
              addConnection(connectorNodes[i], connectorNodes[j], "B");
            }
          }
        }

        // 4) Rare red skips for very distant connections
        // We'll do a pass over random pairs, but only if they're far apart
        for (let i = 0; i < 50; i++) {
          let A = nodes[Math.floor(Math.random()*nodes.length)];
          let B = nodes[Math.floor(Math.random()*nodes.length)];
          if (A === B) continue;
          let d = dist(A.x,A.y,B.x,B.y);
          if (d > 0.5*worldWidth && Math.random()<0.05) {
            addConnection(A,B,"C");
          }
        }

        console.log("Generated", connections.length, "connections total.");
      }

      // Add connection if it doesn't already exist
      function addConnection(nA, nB, type) {
        // check if it already exists
        if (!nA || !nB) return;
        if (nA === nB) return;
        // don't add duplicates
        for (let c of connections) {
          if ((c.source===nA && c.target===nB) ||
              (c.source===nB && c.target===nA)) {
            return;
          }
        }
        connections.push({ source: nA, target: nB, type });
      }

      // ---- Rendering with label text that doesn't scale ----
      function render() {
        // Clear
        ctx.clearRect(0,0,canvas.width, canvas.height);

        // 1) Draw connections in world space
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        connections.forEach(conn => {
          ctx.beginPath();
          ctx.moveTo(conn.source.x, conn.source.y);
          ctx.lineTo(conn.target.x, conn.target.y);
          if (conn.type === "A") ctx.strokeStyle = "green";
          else if (conn.type === "B") ctx.strokeStyle = "blue";
          else ctx.strokeStyle = "red"; // "C"
          ctx.lineWidth = 1.5;
          ctx.stroke();
        });

        // Draw node circles & ships
        nodes.forEach(node => {
          let r = (hoverNode === node) ? 7 : 5;
          ctx.beginPath();
          ctx.arc(node.x,node.y,r,0,Math.PI*2);
          ctx.fillStyle = (hoverNode === node) ? "#ff0" : "#fff";
          ctx.fill();

          // Draw ships orbiting
          node.ships.forEach(ship => {
            const ox = node.x + Math.cos(ship.angle)*ship.orbitRadius;
            const oy = node.y + Math.sin(ship.angle)*ship.orbitRadius;
            ctx.beginPath();
            ctx.arc(ox,oy,4,0,Math.PI*2);
            ctx.fillStyle = "yellow";
            ctx.fill();
          });
        });

        ctx.restore();

        // 2) Draw labels in screen space so text remains the same size
        //    (not scaling with the world).
        nodes.forEach(node => {
          // Convert node world coords to screen coords
          const sc = worldToScreen(node.x,node.y);
          // Slight offset
          let labelX = sc.x + 8;
          let labelY = sc.y - 8;
          // If hovered, highlight the label in yellow
          ctx.font = "10px Orbitron"; 
          ctx.fillStyle = "#ccc";
          if (hoverNode === node) {
            ctx.fillStyle = "#ff0";
          }
          ctx.fillText(node.systemName, labelX, labelY);

          // Also label ships
          node.ships.forEach(ship => {
            // transform orbit coords to screen
            const ox = node.x + Math.cos(ship.angle)*ship.orbitRadius;
            const oy = node.y + Math.sin(ship.angle)*ship.orbitRadius;
            const sPos = worldToScreen(ox,oy);
            ctx.font = "10px Orbitron";
            ctx.fillStyle = "#fff";
            ctx.fillText(ship.name, sPos.x+5, sPos.y);
          });
        });
      }

      // Animate ships
      function animate() {
        nodes.forEach(node => {
          node.ships.forEach(ship => {
            ship.angle += 0.01;
          });
        });
        render();
        requestAnimationFrame(animate);
      }

      // ---- Mouse & Zoom ----
      canvas.addEventListener("mousedown", e => {
        isPanning = true;
        startPan = { x: e.clientX - offsetX, y: e.clientY - offsetY };
      });
      canvas.addEventListener("mousemove", e => {
        if (isPanning) {
          offsetX = e.clientX - startPan.x;
          offsetY = e.clientY - startPan.y;
          render();
        } else {
          // Hover detection
          const {x:mx, y:my} = screenToWorld(e.clientX, e.clientY);
          let foundNode = null;
          let minD = 12;
          for (let node of nodes) {
            if (dist(mx,my,node.x,node.y) < minD) {
              foundNode = node;
              break;
            }
          }
          if (foundNode !== hoverNode) {
            hoverNode = foundNode;
            render();
          }
        }
      });
      canvas.addEventListener("mouseup", () => { isPanning=false; });
      canvas.addEventListener("mouseleave", () => { isPanning=false; });

      // Zoom on wheel around mouse
      canvas.addEventListener("wheel", e => {
        e.preventDefault();
        const {x:wx, y:wy} = screenToWorld(e.clientX, e.clientY);
        const zoomFactor = 0.05;
        if (e.deltaY < 0) {
          // zoom in
          scale *= (1 + zoomFactor);
        } else {
          // zoom out
          scale /= (1 + zoomFactor);
        }
        // Adjust offset so (wx,wy) stays in same screen position
        const {x:sx, y:sy} = worldToScreen(wx,wy);
        // Now sx,sy should remain e.clientX, e.clientY
        offsetX += (e.clientX - sx);
        offsetY += (e.clientY - sy);
        render();
      });

      // ---- Node Click => Edit in sidebar ----
      const systemDetailsTextarea = document.getElementById("systemDetails");
      const regenerateBtn = document.getElementById("regenerateBtn");
      const addShipBtn = document.getElementById("addShipBtn");
      const shipContainer = document.getElementById("shipContainer");

      canvas.addEventListener("click", e => {
        if (isPanning) return;
        const {x:wx, y:wy} = screenToWorld(e.clientX, e.clientY);
        for (let node of nodes) {
          if (dist(wx,wy,node.x,node.y)<8) {
            openSidebar(node);
            return;
          }
        }
      });

      function openSidebar(node) {
        selectedNode = node;
        systemDetailsTextarea.value = node.systemDetails;
        renderShipList(node);
      }

      systemDetailsTextarea.addEventListener("input", e => {
        if (selectedNode) {
          selectedNode.systemDetails = systemDetailsTextarea.value;
        }
      });

      regenerateBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        if (typeof generateSystem === "function" && typeof generateSystemText === "function") {
          generateSystem();
          selectedNode.systemDetails = generateSystemText();
          systemDetailsTextarea.value = selectedNode.systemDetails;
        }
      });

      addShipBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        const shipName = prompt("Enter ship name:");
        if (shipName) {
          selectedNode.ships.push({
            name: shipName,
            orbitRadius: 80 + Math.random()*20, // bigger orbit so they're more visible
            angle: Math.random()*Math.PI*2,
            customData: ""
          });
          renderShipList(selectedNode);
        }
      });

      function renderShipList(node) {
        let html = "";
        node.ships.forEach((ship, idx) => {
          html += `
            <div class="ship-card" id="shipCard${idx}">
              <h4>${ship.name}</h4>
              <textarea oninput="updateShipData(${idx}, this.value)">${ship.customData||""}</textarea>
              <label>Move to: </label>
              <select onchange="moveShip(${idx}, this.value)">
                <option value="">(choose system)</option>
                ${getConnectedSystems(node).map(n => `
                  <option value="${n.id}">${n.systemName}</option>
                `).join("")}
              </select>
              <button onclick="deleteShip(${idx})">Delete</button>
            </div>
          `;
        });
        shipContainer.innerHTML = html;
      }

      function getConnectedSystems(node) {
        // Return all systems directly connected to 'node'
        const connected = [];
        connections.forEach(conn => {
          if (conn.source===node && conn.target!==node) {
            connected.push(conn.target);
          } else if (conn.target===node && conn.source!==node) {
            connected.push(conn.source);
          }
        });
        return connected;
      }

      // Expose these so inline onclick= calls work
      window.updateShipData = function(idx, val) {
        if (!selectedNode) return;
        selectedNode.ships[idx].customData = val;
      };
      window.deleteShip = function(idx) {
        if (!selectedNode) return;
        selectedNode.ships.splice(idx,1);
        renderShipList(selectedNode);
      };
      window.moveShip = function(idx, targetId) {
        if (!selectedNode || !targetId) return;
        const ship = selectedNode.ships[idx];
        const targetNode = nodes.find(n => n.id == targetId);
        if (targetNode && targetNode !== selectedNode) {
          selectedNode.ships.splice(idx,1);
          targetNode.ships.push(ship);
          renderShipList(selectedNode);
        }
      };

      // ---- Searching ----
      document.getElementById("nodeSearch").addEventListener("change", e => {
        const query = e.target.value.toLowerCase();
        const found = nodes.find(n => n.systemName.toLowerCase().includes(query));
        if (found) {
          offsetX = canvas.width/2 - found.x*scale;
          offsetY = canvas.height/2 - found.y*scale;
          render();
        }
      });
      document.getElementById("shipSearch").addEventListener("change", e => {
        const query = e.target.value.toLowerCase();
        for (let node of nodes) {
          const ship = node.ships.find(s => s.name.toLowerCase().includes(query));
          if (ship) {
            offsetX = canvas.width/2 - node.x*scale;
            offsetY = canvas.height/2 - node.y*scale;
            render();
            break;
          }
        }
      });

      // ---- Zoom & Reset Buttons ----
      document.getElementById("zoomInBtn").addEventListener("click", () => {
        const centerX = canvas.width/2;
        const centerY = canvas.height/2;
        const {x:wx, y:wy} = screenToWorld(centerX, centerY);
        scale *= 1.05;
        const {x:sx, y:sy} = worldToScreen(wx,wy);
        offsetX += (centerX - sx);
        offsetY += (centerY - sy);
        render();
      });
      document.getElementById("zoomOutBtn").addEventListener("click", () => {
        const centerX = canvas.width/2;
        const centerY = canvas.height/2;
        const {x:wx, y:wy} = screenToWorld(centerX, centerY);
        scale /= 1.05;
        const {x:sx, y:sy} = worldToScreen(wx,wy);
        offsetX += (centerX - sx);
        offsetY += (centerY - sy);
        render();
      });
      document.getElementById("resetViewBtn").addEventListener("click", () => {
        offsetX = 0;
        offsetY = 0;
        scale = 1;
        render();
      });

      // ---- Save & Load ----
      document.getElementById("saveMapBtn").addEventListener("click", () => {
        const mapData = {
          nodes,
          connections,
          offsetX,
          offsetY,
          scale,
          clusters
        };
        const dataStr = "data:text/json;charset=utf-8," +
          encodeURIComponent(JSON.stringify(mapData, null, 2));
        const dlAnchor = document.createElement("a");
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "galaxy_map.json");
        document.body.appendChild(dlAnchor);
        dlAnchor.click();
        dlAnchor.remove();
      });
      document.getElementById("loadMapInput").addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const loaded = JSON.parse(evt.target.result);
          nodes = loaded.nodes || [];
          connections = loaded.connections || [];
          offsetX = loaded.offsetX || 0;
          offsetY = loaded.offsetY || 0;
          scale = loaded.scale || 1;
          clusters = loaded.clusters || [];
          console.log("Loaded map. Node count:", nodes.length, "Connection count:", connections.length);
          render();
        };
        reader.readAsText(file);
      });

      // ---- Initial Generation & Animate ----
      generateNodes();
      generateConnections();
      render();
      animate();
    });
    </script>
  </body>
</html>
