<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Astral Axial Galaxy Generator</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Make body fill the entire window, with a starry background from styles.css */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
      body {
        /* If your nav is fixed, add top padding. If not, remove. Adjust as needed. */
        padding-top: 60px;
      }
      /* Container for nav.html fetch */
      #navContainer {
        position: relative;
        z-index: 1000; /* Ensure nav is on top */
      }
      /* The canvas should fill the screen below the nav */
      #galaxyCanvas {
        position: absolute;
        top: 60px; /* match bodyâ€™s top padding if nav is fixed at 60px high */
        left: 0;
        /* Fill the remaining space below the nav */
        width: calc(100% - 0px);
        height: calc(100% - 60px);
        background: transparent; /* So starry background shows through if desired */
        cursor: grab;
      }
      #galaxyCanvas:active {
        cursor: grabbing;
      }
      .controls {
        text-align: center;
        margin-top: 10px;
      }
      /* Sidebar for node details */
      #sidebar {
        position: absolute;
        top: 60px;
        right: -400px;
        width: 400px;
        height: calc(100% - 60px);
        background: #262626;
        color: #ccc;
        overflow-y: auto;
        transition: right 0.3s ease;
        padding: 20px;
        z-index: 2000;
      }
      #sidebar.open {
        right: 0;
      }
      #sidebar textarea {
        width: 100%;
        background: #1a1a1a;
        color: #ddd;
        border: 1px solid #555;
        padding: 10px;
        font-family: monospace;
        margin-bottom: 10px;
      }
      /* Hidden output for systemgen.js */
      #systemOutput {
        display: none;
      }
      /* Ships container in the sidebar */
      #shipContainer textarea {
        height: 60px;
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <!-- The nav is loaded into this container -->
    <div id="navContainer"></div>

    <div class="controls">
      <button id="resetViewBtn">Reset View</button>
      <button id="saveMapBtn">Save Map</button>
      <input type="file" id="loadMapInput" accept=".json" />
      <input type="text" id="nodeSearch" placeholder="Search Node" />
      <input type="text" id="shipSearch" placeholder="Search Ship" />
      <button id="zoomInBtn">Zoom In</button>
      <button id="zoomOutBtn">Zoom Out</button>
    </div>

    <!-- The canvas that fills the screen behind the nav bar -->
    <canvas id="galaxyCanvas"></canvas>

    <!-- Sidebar for System Details -->
    <div id="sidebar">
      <h2>System Details</h2>
      <textarea id="systemDetails" rows="6"></textarea>
      <br />
      <button id="regenerateBtn">Regenerate</button>
      <button id="closeSidebarBtn">Close</button>
      <button id="addShipBtn">Add Ship</button>
      <h3>Ships</h3>
      <div id="shipContainer"></div>
    </div>

    <!-- Hidden div so systemgen.js can render the system text if needed -->
    <div id="systemOutput"></div>

    <!-- 1) Load nav via fetch -->
    <script>
      fetch('nav.html')
        .then(response => response.text())
        .then(data => {
          document.getElementById('navContainer').innerHTML = data;
        })
        .catch(err => console.error('Error loading nav:', err));
    </script>

    <!-- 2) Load your systemgen.js -->
    <script src="systemgen.js"></script>

    <!-- 3) Main Galaxy Code -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded. Starting galaxy generator...");

      // Adjust the canvas size to fill the window
      const canvas = document.getElementById("galaxyCanvas");
      const ctx = canvas.getContext("2d");

      // Resize the canvas to fill the window below the nav
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        // Subtract nav height if needed
        canvas.height = window.innerHeight - 60;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Panning & Zooming
      let offsetX = 0,
          offsetY = 0,
          scale = 1;
      let isPanning = false;
      let startPan = { x: 0, y: 0 };

      // Data arrays
      let nodes = [];
      let connections = [];
      let clusters = [];
      let selectedNode = null;
      let hoverNode = null; // For hover highlighting

      // Make the galaxy smaller/closer
      const worldWidth = 3000;
      const worldHeight = 3000;

      // ---- Helper function: distance ----
      function dist(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // ---- Cluster & Node Generation ----
      function generateClusters() {
        clusters = [];
        const clusterCount = Math.floor(Math.random() * 3) + 4; // 4-6 clusters
        for (let i = 0; i < clusterCount; i++) {
          const center = {
            x: Math.random() * worldWidth,
            y: Math.random() * worldHeight,
          };
          // Slightly smaller radius to keep clusters closer
          const radius = Math.random() * 100 + 50; // 50-150
          clusters.push({ center, radius, nodes: [] });
        }
      }

      function generateNodes() {
        nodes = [];
        generateClusters();
        const totalNodes = 500;
        let nodesPerCluster = Math.floor(totalNodes / clusters.length);
        let extraNodes = totalNodes % clusters.length;

        clusters.forEach((cluster) => {
          let count = nodesPerCluster;
          if (extraNodes > 0) {
            count++;
            extraNodes--;
          }
          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * cluster.radius;
            const x = cluster.center.x + Math.cos(angle) * distance;
            const y = cluster.center.y + Math.sin(angle) * distance;

            // Use the 6-digit code from systemgen.js
            let systemName = "System " + (nodes.length + 1);
            if (typeof generateSystemCode === "function") {
              systemName = generateSystemCode(); // e.g., "AB12C3"
            }

            let systemText = "System details not available.";
            if (typeof generateSystem === "function" &&
                typeof generateSystemText === "function") {
              generateSystem();  // calls systemgen's generation
              systemText = generateSystemText();
            }

            const node = {
              id: nodes.length,
              x,
              y,
              cluster,
              systemName,
              systemDetails: systemText,
              ships: [], // array of ships
            };
            nodes.push(node);
            cluster.nodes.push(node);
          }
        });
        console.log("Generated", nodes.length, "nodes in", clusters.length, "clusters.");
      }

      // ---- Connection Generation ----
      function generateConnections() {
        connections = [];
        // Type A: connect nodes within the same cluster
        clusters.forEach((cluster) => {
          const cNodes = cluster.nodes;
          for (let i = 0; i < cNodes.length; i++) {
            for (let j = i + 1; j < cNodes.length; j++) {
              // Random chance to connect
              if (Math.random() < 0.05) {
                connections.push({
                  source: cNodes[i],
                  target: cNodes[j],
                  type: "A",
                });
              }
            }
          }
        });

        // Inter-cluster connections
        for (let i = 0; i < clusters.length; i++) {
          for (let j = i + 1; j < clusters.length; j++) {
            const cA = clusters[i];
            const cB = clusters[j];
            const dx = cA.center.x - cB.center.x;
            const dy = cA.center.y - cB.center.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            // Type B for closer clusters, Type C for far
            let connectionType = d > (worldWidth / 3) ? "C" : "B";
            // Create 1-3 random connections
            const connCount = Math.floor(Math.random() * 3) + 1;
            for (let k = 0; k < connCount; k++) {
              const nodeA = cA.nodes[Math.floor(Math.random() * cA.nodes.length)];
              const nodeB = cB.nodes[Math.floor(Math.random() * cB.nodes.length)];
              connections.push({
                source: nodeA,
                target: nodeB,
                type: connectionType,
              });
            }
          }
        }
        console.log("Generated", connections.length, "connections.");
      }

      // ---- Rendering ----
      function render() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Draw connections
        connections.forEach((conn) => {
          ctx.beginPath();
          ctx.moveTo(conn.source.x, conn.source.y);
          ctx.lineTo(conn.target.x, conn.target.y);
          if (conn.type === "A") ctx.strokeStyle = "green";
          else if (conn.type === "B") ctx.strokeStyle = "blue";
          else ctx.strokeStyle = "red"; // type C
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        // Draw nodes
        nodes.forEach((node) => {
          // If hovered, highlight bigger circle
          let radius = (hoverNode === node) ? 8 : 5;
          ctx.beginPath();
          ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = (hoverNode === node) ? "#ff0" : "#fff";
          ctx.fill();

          // Attempt to offset label to reduce overlap
          // Simple approach: shift label by a small random or node.id-based offset
          let labelOffsetY = -8 - (node.id % 10); 
          ctx.font = "12px Orbitron";
          ctx.fillStyle = "#ccc";
          ctx.fillText(node.systemName, node.x + 8, node.y + labelOffsetY);
        });

        ctx.restore();
      }

      // ---- Animate (ship orbits) ----
      function animate() {
        nodes.forEach((node) => {
          node.ships.forEach((ship) => {
            ship.angle += 0.01; // slow orbit
          });
        });
        render();
        requestAnimationFrame(animate);
      }

      // ---- Mouse/Panning/Zooming ----
      canvas.addEventListener("mousedown", (e) => {
        isPanning = true;
        startPan = { x: e.clientX - offsetX, y: e.clientY - offsetY };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isPanning) {
          offsetX = e.clientX - startPan.x;
          offsetY = e.clientY - startPan.y;
          render();
        } else {
          // Hover detection
          const rect = canvas.getBoundingClientRect();
          const mx = (e.clientX - rect.left - offsetX) / scale;
          const my = (e.clientY - rect.top - offsetY) / scale;
          let foundNode = null;
          let minDist = 15;
          // Find the closest node within 15px
          for (let node of nodes) {
            const d = dist(mx, my, node.x, node.y);
            if (d < minDist) {
              minDist = d;
              foundNode = node;
            }
          }
          if (foundNode !== hoverNode) {
            hoverNode = foundNode;
            render();
          }
        }
      });

      canvas.addEventListener("mouseup", () => {
        isPanning = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isPanning = false;
      });

      // Mouse-wheel zoom that centers on the mouse pointer
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offsetX) / scale;
        const mouseY = (e.clientY - rect.top - offsetY) / scale;
        let zoomFactor = 0.05; // smaller = slower zoom
        if (e.deltaY < 0) {
          // zoom in
          scale *= (1 + zoomFactor);
        } else {
          // zoom out
          scale /= (1 + zoomFactor);
        }
        // Recompute offset so the mouse point stays in the same place
        offsetX = e.clientX - (mouseX * scale);
        offsetY = e.clientY - (mouseY * scale);
        render();
      });

      // ---- Node Click -> Sidebar ----
      const sidebar = document.getElementById("sidebar");
      const systemDetailsTextarea = document.getElementById("systemDetails");
      const regenerateBtn = document.getElementById("regenerateBtn");
      const closeSidebarBtn = document.getElementById("closeSidebarBtn");
      const addShipBtn = document.getElementById("addShipBtn");
      const shipContainer = document.getElementById("shipContainer");

      function openSidebar(node) {
        selectedNode = node;
        systemDetailsTextarea.value = node.systemDetails;
        sidebar.classList.add("open");

        // Display each ship with a text area
        renderShips(node);
      }

      function renderShips(node) {
        let html = "";
        node.ships.forEach((ship, index) => {
          // Each ship has a name, an orbitRadius, angle, and a "customData" text
          html += `
            <div style="border:1px solid #444; padding:5px; margin-bottom:5px;">
              <strong>${ship.name}</strong><br/>
              <label>Ship Data:</label>
              <textarea id="shipData${index}" rows="3">${ship.customData || ""}</textarea>
              <br/>
              <button onclick="updateShipData(${index})">Save</button>
            </div>
          `;
        });
        shipContainer.innerHTML = html;
      }

      // Provide a global function so inline onclick can access it
      window.updateShipData = function(index) {
        const ta = document.getElementById("shipData" + index);
        if (ta && selectedNode) {
          selectedNode.ships[index].customData = ta.value;
        }
      };

      canvas.addEventListener("click", (e) => {
        if (isPanning) return; // ignore clicks if panning
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;
        for (let node of nodes) {
          if (dist(x, y, node.x, node.y) < 8) {
            openSidebar(node);
            return;
          }
        }
      });

      regenerateBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        if (typeof generateSystem === "function" &&
            typeof generateSystemText === "function") {
          // Regenerate system text, store in selected node
          generateSystem();
          selectedNode.systemDetails = generateSystemText();
          systemDetailsTextarea.value = selectedNode.systemDetails;
        }
      });

      closeSidebarBtn.addEventListener("click", () => {
        sidebar.classList.remove("open");
      });

      addShipBtn.addEventListener("click", () => {
        if (!selectedNode) return;
        const shipName = prompt("Enter ship name:");
        if (shipName) {
          selectedNode.ships.push({
            name: shipName,
            orbitRadius: 20 + Math.random() * 10,
            angle: Math.random() * Math.PI * 2,
            customData: ""
          });
        }
        renderShips(selectedNode);
      });

      // ---- Searching for Node or Ship ----
      document.getElementById("nodeSearch").addEventListener("change", (e) => {
        const query = e.target.value.toLowerCase();
        const found = nodes.find((n) =>
          n.systemName.toLowerCase().includes(query)
        );
        if (found) {
          offsetX = canvas.width / 2 - found.x * scale;
          offsetY = canvas.height / 2 - found.y * scale;
          render();
        }
      });
      document.getElementById("shipSearch").addEventListener("change", (e) => {
        const query = e.target.value.toLowerCase();
        for (let node of nodes) {
          const ship = node.ships.find((s) =>
            s.name.toLowerCase().includes(query)
          );
          if (ship) {
            offsetX = canvas.width / 2 - node.x * scale;
            offsetY = canvas.height / 2 - node.y * scale;
            render();
            break;
          }
        }
      });

      // ---- Zoom & Reset ----
      document.getElementById("zoomInBtn").addEventListener("click", () => {
        scale *= 1.05; // gentler zoom
        render();
      });
      document.getElementById("zoomOutBtn").addEventListener("click", () => {
        scale /= 1.05;
        render();
      });
      document.getElementById("resetViewBtn").addEventListener("click", () => {
        offsetX = 0;
        offsetY = 0;
        scale = 1;
        render();
      });

      // ---- Save & Load ----
      document.getElementById("saveMapBtn").addEventListener("click", () => {
        const mapData = {
          nodes,
          connections,
          offsetX,
          offsetY,
          scale,
          clusters
        };
        const dataStr = "data:text/json;charset=utf-8," +
          encodeURIComponent(JSON.stringify(mapData, null, 2));
        const dlAnchorElem = document.createElement("a");
        dlAnchorElem.setAttribute("href", dataStr);
        dlAnchorElem.setAttribute("download", "galaxy_map.json");
        document.body.appendChild(dlAnchorElem);
        dlAnchorElem.click();
        dlAnchorElem.remove();
      });

      document.getElementById("loadMapInput").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
          const loadedData = JSON.parse(evt.target.result);
          nodes = loadedData.nodes || [];
          connections = loadedData.connections || [];
          offsetX = loadedData.offsetX || 0;
          offsetY = loadedData.offsetY || 0;
          scale = loadedData.scale || 1;
          clusters = loadedData.clusters || [];
          console.log("Loaded map. Node count:", nodes.length, "Connection count:", connections.length);
          render();
        };
        reader.readAsText(file);
      });

      // ---- Initial Generation & Animation ----
      generateNodes();
      generateConnections();
      render();
      animate();
    });
    </script>
  </body>
</html>
